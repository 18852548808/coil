{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"An image loading library for Android backed by Kotlin Coroutines. Coil is: Fast : Coil performs a number of optimizations including memory and disk caching, downsampling the image in memory, re-using Bitmaps, automatically pausing/cancelling requests, and more. Lightweight : Coil adds ~1500 methods to your APK (for apps that already use OkHttp and Coroutines), which is comparable to Picasso and significantly less than Glide and Fresco. Easy to use : Coil's API leverages Kotlin's language features for simplicity and minimal boilerplate. Modern : Coil is Kotlin-first and uses modern libraries including Coroutines, OkHttp, Okio, and AndroidX Lifecycles. Coil is an acronym for: Co routine I mage L oader. Made with \u2764\ufe0f at Instacart . Download Coil is available on mavenCentral() . implementation ( io.coil-kt:coil:0.6.0 ) Quick Start To load an image into an ImageView , use the load extension function: // URL imageView . load ( https://www.example.com/image.jpg ) // Resource imageView . load ( R . drawable . image ) // File imageView . load ( File ( /path/to/image.jpg )) // And more... Requests can be configured with an optional trailing lambda: imageView . load ( https://www.example.com/image.jpg ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } To get an image imperatively, use the get suspend function: val drawable = Coil . get ( https://www.example.com/image.jpg ) Requirements AndroidX Min SDK 14+ Compile SDK: 28+ Java 8+ R8 / Proguard Coil is fully compatible with R8 out of the box and doesn't require adding any extra rules. If you use Proguard, you may need to add rules for Coroutines , OkHttp and Okio . License Copyright 2019 Coil Contributors Licensed under the Apache License, Version 2.0 (the License ); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#download","text":"Coil is available on mavenCentral() . implementation ( io.coil-kt:coil:0.6.0 )","title":"Download"},{"location":"#quick-start","text":"To load an image into an ImageView , use the load extension function: // URL imageView . load ( https://www.example.com/image.jpg ) // Resource imageView . load ( R . drawable . image ) // File imageView . load ( File ( /path/to/image.jpg )) // And more... Requests can be configured with an optional trailing lambda: imageView . load ( https://www.example.com/image.jpg ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } To get an image imperatively, use the get suspend function: val drawable = Coil . get ( https://www.example.com/image.jpg )","title":"Quick Start"},{"location":"#requirements","text":"AndroidX Min SDK 14+ Compile SDK: 28+ Java 8+","title":"Requirements"},{"location":"#r8-proguard","text":"Coil is fully compatible with R8 out of the box and doesn't require adding any extra rules. If you use Proguard, you may need to add rules for Coroutines , OkHttp and Okio .","title":"R8 / Proguard"},{"location":"#license","text":"Copyright 2019 Coil Contributors Licensed under the Apache License, Version 2.0 (the License ); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"changelog/","text":"Changelog [Unreleased] - mm dd, yyyy None. [0.6.0] - August 12, 2019 Initial release.","title":"Change Log"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#unreleased-mm-dd-yyyy","text":"None.","title":"[Unreleased] - mm dd, yyyy"},{"location":"changelog/#060-august-12-2019","text":"Initial release.","title":"[0.6.0] - August 12, 2019"},{"location":"code_of_conduct/","text":"Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at colin colinwhite.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Code of Conduct"},{"location":"code_of_conduct/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at colin colinwhite.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"contributing/","text":"Contributing In an effort to keep the library small and stable, please keep contributions limited to bug fixes, documentation improvements, and test improvements. If you have a new feature idea, please build it in an external library. If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it. If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code passes all tests by running ./test.sh . Modified from OkHttp's Contributing section.","title":"Contributing"},{"location":"contributing/#contributing","text":"In an effort to keep the library small and stable, please keep contributions limited to bug fixes, documentation improvements, and test improvements. If you have a new feature idea, please build it in an external library. If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it. If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code passes all tests by running ./test.sh . Modified from OkHttp's Contributing section.","title":"Contributing"},{"location":"faq/","text":"FAQ Have a question that isn't part of the FAQ? Check StackOverflow with the tag #coil. We monitor that tag for any new questions. Can Coil be used with Java projects or mixed Kotlin/Java projects? Yes! Read more here . How do I preload an image? Read here .","title":"FAQ"},{"location":"faq/#faq","text":"Have a question that isn't part of the FAQ? Check StackOverflow with the tag #coil. We monitor that tag for any new questions.","title":"FAQ"},{"location":"faq/#can-coil-be-used-with-java-projects-or-mixed-kotlinjava-projects","text":"Yes! Read more here .","title":"Can Coil be used with Java projects or mixed Kotlin/Java projects?"},{"location":"faq/#how-do-i-preload-an-image","text":"Read here .","title":"How do I preload an image?"},{"location":"getting_started/","text":"Getting Started Artifacts Coil has 3 artifacts published to mavenCentral() : io.coil-kt:coil : The default artifact, which includes the Coil singleton. io.coil-kt:coil-base : The base artifact, which does not include the Coil singleton. Prefer this artifact if you want to use dependency injection to inject your ImageLoader instance(s). io.coil-kt:coil-gif : Includes a set of decoders to support decoding GIFs. See GIFs for more details. Java 8 Coil requires Java 8 bytecode. To enable Java 8 desugaring by D8 : Gradle ( .gradle ): android { compileOptions { sourceCompatibility JavaVersion . VERSION_1_8 targetCompatibility JavaVersion . VERSION_1_8 } } tasks . withType ( org . jetbrains . kotlin . gradle . tasks . KotlinCompile ). all { kotlinOptions { jvmTarget = 1.8 } } Gradle Kotlin DSL ( .gradle.kts ): android { compileOptions { sourceCompatibility = JavaVersion . VERSION_1_8 targetCompatibility = JavaVersion . VERSION_1_8 } } tasks . withType KotlinCompile { kotlinOptions { jvmTarget = 1.8 } } API The heart of Coil's API is the ImageLoader . ImageLoader exposes two methods for image loading: load : Starts an asynchronous request to load the data into the Target . fun load ( request : LoadRequest ): RequestDisposable get : A suspend function, which returns a Drawable . suspend fun get ( request : GetRequest ): Drawable Extension Functions Coil provides a set of extension functions for ImageLoader s, ImageView s, and the Coil singleton to provide type-safe methods. Here's an example for loading a URL into an ImageView : imageView . load ( https://www.example.com/image.jpg ) By default, requests are initialized with the options from DefaultRequestOptions , however each individual request can be configured with an optional trailing lambda param: imageView . load ( https://www.example.com/image.jpg ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } See the docs here and here for more information. Supported Data Types The base data types that are supported by all ImageLoader instances are: String (mapped to HttpUrl) HttpUrl Uri ( android.resource , content , file , http , and https schemes only) File (mapped to file Uri) @DrawableRes Int Drawable Bitmap Preloading To preload an image into memory, execute a load request without a Target : Coil . load ( context , https://www.example.com/image.jpg ) To only preload the image into the disk cache, disable the memory cache for the request: Coil . load ( context , https://www.example.com/image.jpg ) { memoryCachePolicy ( CachePolicy . DISABLED ) } Cancelling Requests load requests will be automatically cancelled if the associated View is detached, the associated Lifecycle is destroyed, or another request is started on the same View . Furthermore, each load request returns a RequestDisposable , which can be used to check if a request is in flight or dispose the request (effectively cancelling it and freeing its associated resources): val disposable = imageView . load ( https://www.example.com/image.jpg ) // Cancel the request. disposable . dispose () get requests will only be cancelled if the coroutine context's job is cancelled. Image Sampling Suppose you have an image that is 500x500 on disk, but you only need to load it into memory at 100x100 to be displayed in a view. Coil will load the image into memory, but what happens now if you need the image at 500x500? There's still more \"quality\" to read from disk, but the image is already loaded into memory at 100x100. Ideally, we would use the 100x100 image as a placeholder while we read the image from disk at 500x500. This is exactly what Coil does and Coil handles this process automatically for all BitmapDrawables . Paired with crossfade(true) , this can create a visual effect where the image detail appears to fade in, similar to a progressive JPEG . Here's what it looks like in the sample app: Images in the list have intentionally been loaded with very low detail and the crossfade is slowed down to highlight the visual effect. Bitmap Pooling Similar to Glide and Fresco, Coil supports bitmap pooling. Bitmap pooling is a technique to re-use Bitmap objects once they are no longer in use (i.e. when a View is detached, a Fragment's view is destroyed, etc.). This can significantly improve memory performance (especially on pre-Oreo devices), however it creates several API limitations. To make this optimization as seamless and transparent to the consumer as possible, Targets must opt-in to bitmap pooling. To opt in, implement PoolableViewTarget ; this requires the target to release all references to its current Drawable when its next lifecycle method is called. See PoolableViewTarget for more information. Note Do not use ImageView.getDrawable if the ImageView 's Drawable has been set through Coil's ImageViewTarget . Instead, either load the image using a custom Target or copy underlying Bitmap using Bitmap.copy .","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#artifacts","text":"Coil has 3 artifacts published to mavenCentral() : io.coil-kt:coil : The default artifact, which includes the Coil singleton. io.coil-kt:coil-base : The base artifact, which does not include the Coil singleton. Prefer this artifact if you want to use dependency injection to inject your ImageLoader instance(s). io.coil-kt:coil-gif : Includes a set of decoders to support decoding GIFs. See GIFs for more details.","title":"Artifacts"},{"location":"getting_started/#java-8","text":"Coil requires Java 8 bytecode. To enable Java 8 desugaring by D8 : Gradle ( .gradle ): android { compileOptions { sourceCompatibility JavaVersion . VERSION_1_8 targetCompatibility JavaVersion . VERSION_1_8 } } tasks . withType ( org . jetbrains . kotlin . gradle . tasks . KotlinCompile ). all { kotlinOptions { jvmTarget = 1.8 } } Gradle Kotlin DSL ( .gradle.kts ): android { compileOptions { sourceCompatibility = JavaVersion . VERSION_1_8 targetCompatibility = JavaVersion . VERSION_1_8 } } tasks . withType KotlinCompile { kotlinOptions { jvmTarget = 1.8 } }","title":"Java 8"},{"location":"getting_started/#api","text":"The heart of Coil's API is the ImageLoader . ImageLoader exposes two methods for image loading: load : Starts an asynchronous request to load the data into the Target . fun load ( request : LoadRequest ): RequestDisposable get : A suspend function, which returns a Drawable . suspend fun get ( request : GetRequest ): Drawable","title":"API"},{"location":"getting_started/#extension-functions","text":"Coil provides a set of extension functions for ImageLoader s, ImageView s, and the Coil singleton to provide type-safe methods. Here's an example for loading a URL into an ImageView : imageView . load ( https://www.example.com/image.jpg ) By default, requests are initialized with the options from DefaultRequestOptions , however each individual request can be configured with an optional trailing lambda param: imageView . load ( https://www.example.com/image.jpg ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } See the docs here and here for more information.","title":"Extension Functions"},{"location":"getting_started/#supported-data-types","text":"The base data types that are supported by all ImageLoader instances are: String (mapped to HttpUrl) HttpUrl Uri ( android.resource , content , file , http , and https schemes only) File (mapped to file Uri) @DrawableRes Int Drawable Bitmap","title":"Supported Data Types"},{"location":"getting_started/#preloading","text":"To preload an image into memory, execute a load request without a Target : Coil . load ( context , https://www.example.com/image.jpg ) To only preload the image into the disk cache, disable the memory cache for the request: Coil . load ( context , https://www.example.com/image.jpg ) { memoryCachePolicy ( CachePolicy . DISABLED ) }","title":"Preloading"},{"location":"getting_started/#cancelling-requests","text":"load requests will be automatically cancelled if the associated View is detached, the associated Lifecycle is destroyed, or another request is started on the same View . Furthermore, each load request returns a RequestDisposable , which can be used to check if a request is in flight or dispose the request (effectively cancelling it and freeing its associated resources): val disposable = imageView . load ( https://www.example.com/image.jpg ) // Cancel the request. disposable . dispose () get requests will only be cancelled if the coroutine context's job is cancelled.","title":"Cancelling Requests"},{"location":"getting_started/#image-sampling","text":"Suppose you have an image that is 500x500 on disk, but you only need to load it into memory at 100x100 to be displayed in a view. Coil will load the image into memory, but what happens now if you need the image at 500x500? There's still more \"quality\" to read from disk, but the image is already loaded into memory at 100x100. Ideally, we would use the 100x100 image as a placeholder while we read the image from disk at 500x500. This is exactly what Coil does and Coil handles this process automatically for all BitmapDrawables . Paired with crossfade(true) , this can create a visual effect where the image detail appears to fade in, similar to a progressive JPEG . Here's what it looks like in the sample app: Images in the list have intentionally been loaded with very low detail and the crossfade is slowed down to highlight the visual effect.","title":"Image Sampling"},{"location":"getting_started/#bitmap-pooling","text":"Similar to Glide and Fresco, Coil supports bitmap pooling. Bitmap pooling is a technique to re-use Bitmap objects once they are no longer in use (i.e. when a View is detached, a Fragment's view is destroyed, etc.). This can significantly improve memory performance (especially on pre-Oreo devices), however it creates several API limitations. To make this optimization as seamless and transparent to the consumer as possible, Targets must opt-in to bitmap pooling. To opt in, implement PoolableViewTarget ; this requires the target to release all references to its current Drawable when its next lifecycle method is called. See PoolableViewTarget for more information. Note Do not use ImageView.getDrawable if the ImageView 's Drawable has been set through Coil's ImageViewTarget . Instead, either load the image using a custom Target or copy underlying Bitmap using Bitmap.copy .","title":"Bitmap Pooling"},{"location":"gifs/","text":"Gifs Unlike Glide, GIFs are not supported by default. However, Coil has an extension library to support them. To add GIF support, import the extension library: implementation ( io.coil-kt:coil-gif:0.6.0 ) And add the decoders to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader ( context ) { componentRegistry { if ( SDK_INT = P ) { add ( ImageDecoderDecoder ()) } else { add ( GifDecoder ()) } } } Note Prefer using ImageDecoderDecoder on Android P and above, as it's backed by Android P's new ImageDecoder API. This provides native support for GIFs and Animated WebPs . And that's it! The ImageLoader will automatically detect any GIFs using their file headers and decode them correctly.","title":"GIFs"},{"location":"gifs/#gifs","text":"Unlike Glide, GIFs are not supported by default. However, Coil has an extension library to support them. To add GIF support, import the extension library: implementation ( io.coil-kt:coil-gif:0.6.0 ) And add the decoders to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader ( context ) { componentRegistry { if ( SDK_INT = P ) { add ( ImageDecoderDecoder ()) } else { add ( GifDecoder ()) } } } Note Prefer using ImageDecoderDecoder on Android P and above, as it's backed by Android P's new ImageDecoder API. This provides native support for GIFs and Animated WebPs . And that's it! The ImageLoader will automatically detect any GIFs using their file headers and decode them correctly.","title":"Gifs"},{"location":"image_loaders/","text":"Image Loaders Image Loaders are service objects that handle image requests with load and get . They handle caching, image decoding, request management, bitmap pooling, memory management, and more. New instances can be created like so: val imageLoader = ImageLoader ( context ) Similar to Requests , Image Loader s can be configured with an optional trailing lambda param: val imageLoader = ImageLoader ( context ) { availableMemoryPercentage ( 0.5 ) bitmapPoolPercentage ( 0.5 ) crossfade ( true ) } Internally, this constructs a RealImageLoader using ImageLoaderBuilder . Singleton vs. Dependency Injection Ideally, you should construct and inject your ImageLoader instance(s) using dependency injection. This will scale well as your app grows and it is the best way to manage multiple ImageLoader instances. However, for simple use cases the io.coil-kt:coil artifact provides a default ImageLoader instance that can be accessed with Coil.loader() . Both ImageView.load and Coil.load use the default ImageLoader instance as a default parameter: inline fun ImageView . load ( url : String ?, imageLoader : ImageLoader = Coil . loader (), builder : LoadRequestBuilder .() - Unit = {} ): RequestDisposable { return imageLoader . load ( context , url ) { target ( this @load ) builder () } } The ImageView extension function can be called with a specific ImageLoader like so: imageView . load ( https://www.example.com/image.jpg , imageLoader ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } The default ImageLoader is instantiated lazily and can be replaced with Coil.setDefaultImageLoader . Note Use the io.coil-kt:coil-base artifact if you are using dependency injection. Testing ImageLoader is an interface, which you can replace with a fake implementation. For instance, you could inject a fake ImageLoader implementation which always returns the same Drawable synchronously: val fakeImageLoader = object : ImageLoader { private val drawable = ColorDrawable ( Color . BLACK ) private val disposable = object : RequestDisposable { override fun isDisposed () = true override fun dispose () {} } override val defaults = DefaultRequestOptions () override fun load ( request : LoadRequest ): RequestDisposable { // Always call onStart before onSuccess. request . target ?. onStart ( drawable ) request . target ?. onSuccess ( drawable ) return disposable } override suspend fun get ( request : GetRequest ) = drawable override fun clearMemory () {} override fun shutdown () {} } This is perfect for screenshot and instrumentation tests where you want consistent rendering behavior.","title":"Image Loaders"},{"location":"image_loaders/#image-loaders","text":"Image Loaders are service objects that handle image requests with load and get . They handle caching, image decoding, request management, bitmap pooling, memory management, and more. New instances can be created like so: val imageLoader = ImageLoader ( context ) Similar to Requests , Image Loader s can be configured with an optional trailing lambda param: val imageLoader = ImageLoader ( context ) { availableMemoryPercentage ( 0.5 ) bitmapPoolPercentage ( 0.5 ) crossfade ( true ) } Internally, this constructs a RealImageLoader using ImageLoaderBuilder .","title":"Image Loaders"},{"location":"image_loaders/#singleton-vs-dependency-injection","text":"Ideally, you should construct and inject your ImageLoader instance(s) using dependency injection. This will scale well as your app grows and it is the best way to manage multiple ImageLoader instances. However, for simple use cases the io.coil-kt:coil artifact provides a default ImageLoader instance that can be accessed with Coil.loader() . Both ImageView.load and Coil.load use the default ImageLoader instance as a default parameter: inline fun ImageView . load ( url : String ?, imageLoader : ImageLoader = Coil . loader (), builder : LoadRequestBuilder .() - Unit = {} ): RequestDisposable { return imageLoader . load ( context , url ) { target ( this @load ) builder () } } The ImageView extension function can be called with a specific ImageLoader like so: imageView . load ( https://www.example.com/image.jpg , imageLoader ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } The default ImageLoader is instantiated lazily and can be replaced with Coil.setDefaultImageLoader . Note Use the io.coil-kt:coil-base artifact if you are using dependency injection.","title":"Singleton vs. Dependency Injection"},{"location":"image_loaders/#testing","text":"ImageLoader is an interface, which you can replace with a fake implementation. For instance, you could inject a fake ImageLoader implementation which always returns the same Drawable synchronously: val fakeImageLoader = object : ImageLoader { private val drawable = ColorDrawable ( Color . BLACK ) private val disposable = object : RequestDisposable { override fun isDisposed () = true override fun dispose () {} } override val defaults = DefaultRequestOptions () override fun load ( request : LoadRequest ): RequestDisposable { // Always call onStart before onSuccess. request . target ?. onStart ( drawable ) request . target ?. onSuccess ( drawable ) return disposable } override suspend fun get ( request : GetRequest ) = drawable override fun clearMemory () {} override fun shutdown () {} } This is perfect for screenshot and instrumentation tests where you want consistent rendering behavior.","title":"Testing"},{"location":"image_pipeline/","text":"Extending the Image Pipeline Android supports many image formats out of the box, however there are also plenty of formats it does not (e.g. GIF, SVG, TIFF, etc.) Fortunately, ImageLoaders support pluggable components to add new data types, new fetching behavior, new image encodings, or otherwise overwrite the base image loading behavior. Coil's image pipeline consists of three main parts: Mappers , Fetchers , and Decoders . Custom components must be added to the ImageLoader when constructing it through its ComponentRegistry : val imageLoader = ImageLoader ( context ) { componentRegistry { add ( ItemMapper ()) add ( ProtocolBufferFetcher ()) add ( GifDecoder ()) } } Mappers Mappers allow you to add support for custom data types. For instance, say we get this model from our server: data class Item ( val id : Int , val imageUrl : String , val price : Int , val weight : Double ) We could write a custom mapper to map it to an HttpUrl : class ItemMapper : Mapper Item , HttpUrl { override fun map ( data : Item ): HttpUrl = HttpUrl . get ( data . imageUrl ) } After registering it when constructing our ImageLoader (see above), we can safely load an Item : imageView . loadAny ( item ) loadAny is the type-unsafe version of load that accepts any data type. If you want to know a Target 's size when mapping an object, you can extend from Measured Mapper . Note Extending from Measured Mapper can prevent setting placeholders and or cached drawables synchronously, as they force Coil to wait for the target to be measured. Prefer extending Mapper if you do not need to know the Target 's size. See Mapper and Measured Mapper for more information. Fetchers Fetchers translate data into either a BufferedSource or a Drawable . See Fetcher for more information. Decoders Decoders read a BufferedSource as input and return a Drawable . Use this interface to add support for custom file formats (e.g. GIF, SVG, TIFF, etc.). See Decoder for more information. Note Decoders are responsible for closing the BufferedSource when finished. This allows custom decoders to return a Drawable while still reading the source. This can be useful to support file types such as progressive JPEG where there is incremental information to show.","title":"Extending the Image Pipeline"},{"location":"image_pipeline/#extending-the-image-pipeline","text":"Android supports many image formats out of the box, however there are also plenty of formats it does not (e.g. GIF, SVG, TIFF, etc.) Fortunately, ImageLoaders support pluggable components to add new data types, new fetching behavior, new image encodings, or otherwise overwrite the base image loading behavior. Coil's image pipeline consists of three main parts: Mappers , Fetchers , and Decoders . Custom components must be added to the ImageLoader when constructing it through its ComponentRegistry : val imageLoader = ImageLoader ( context ) { componentRegistry { add ( ItemMapper ()) add ( ProtocolBufferFetcher ()) add ( GifDecoder ()) } }","title":"Extending the Image Pipeline"},{"location":"image_pipeline/#mappers","text":"Mappers allow you to add support for custom data types. For instance, say we get this model from our server: data class Item ( val id : Int , val imageUrl : String , val price : Int , val weight : Double ) We could write a custom mapper to map it to an HttpUrl : class ItemMapper : Mapper Item , HttpUrl { override fun map ( data : Item ): HttpUrl = HttpUrl . get ( data . imageUrl ) } After registering it when constructing our ImageLoader (see above), we can safely load an Item : imageView . loadAny ( item ) loadAny is the type-unsafe version of load that accepts any data type. If you want to know a Target 's size when mapping an object, you can extend from Measured Mapper . Note Extending from Measured Mapper can prevent setting placeholders and or cached drawables synchronously, as they force Coil to wait for the target to be measured. Prefer extending Mapper if you do not need to know the Target 's size. See Mapper and Measured Mapper for more information.","title":"Mappers"},{"location":"image_pipeline/#fetchers","text":"Fetchers translate data into either a BufferedSource or a Drawable . See Fetcher for more information.","title":"Fetchers"},{"location":"image_pipeline/#decoders","text":"Decoders read a BufferedSource as input and return a Drawable . Use this interface to add support for custom file formats (e.g. GIF, SVG, TIFF, etc.). See Decoder for more information. Note Decoders are responsible for closing the BufferedSource when finished. This allows custom decoders to return a Drawable while still reading the source. This can be useful to support file types such as progressive JPEG where there is incremental information to show.","title":"Decoders"},{"location":"java_compatibility/","text":"Java Compatibility Coil's API was designed to be Kotlin-first. It leverages Kotlin language features such as inlined lambdas, receiver params, default arguments, and extension functions, which are not available in Java. Also, suspend functions cannot be implemented in Java. This means custom Transformations , Size Resolvers , Fetchers , and Decoders must be implemented in Kotlin. With these limitations in mind, here is the recommended way to execute load requests from Java: LoadRequest request = ImageLoaders . newLoadBuilder ( imageLoader , context ) . data ( https://www.example.com/image.jpg ) . crossfade ( true ) . target ( imageView ) . build (); imageLoader . load ( request ); If you're using the default ImageLoader , you can get it via Coil.loader() . Note You should not use the API extension functions in Java. Instead, you should create Request objects manually like above. suspend functions cannot be easily called from Java. Thus, to get an image synchronously you'll have to create a wrapper function for get : object ImageLoaderCompat { @JvmStatic @WorkerThread fun getBlocking ( imageLoader : ImageLoader , request : GetRequest ): Drawable = runBlocking { imageLoader . get ( request ) } } Then call the ImageLoaderCompat function from Java: GetRequest request = ImageLoaders . newGetBuilder ( imageLoader ) . data ( https://www.example.com/image.jpg ) . size ( 1080 , 1920 ) . build (); Drawable drawable = ImageLoaderCompat . getBlocking ( imageLoader , request ); Note ImageLoaderCompat.getBlocking will block the current thread instead of suspending. Do not call this from the main thread.","title":"Java Compatibility"},{"location":"java_compatibility/#java-compatibility","text":"Coil's API was designed to be Kotlin-first. It leverages Kotlin language features such as inlined lambdas, receiver params, default arguments, and extension functions, which are not available in Java. Also, suspend functions cannot be implemented in Java. This means custom Transformations , Size Resolvers , Fetchers , and Decoders must be implemented in Kotlin. With these limitations in mind, here is the recommended way to execute load requests from Java: LoadRequest request = ImageLoaders . newLoadBuilder ( imageLoader , context ) . data ( https://www.example.com/image.jpg ) . crossfade ( true ) . target ( imageView ) . build (); imageLoader . load ( request ); If you're using the default ImageLoader , you can get it via Coil.loader() . Note You should not use the API extension functions in Java. Instead, you should create Request objects manually like above. suspend functions cannot be easily called from Java. Thus, to get an image synchronously you'll have to create a wrapper function for get : object ImageLoaderCompat { @JvmStatic @WorkerThread fun getBlocking ( imageLoader : ImageLoader , request : GetRequest ): Drawable = runBlocking { imageLoader . get ( request ) } } Then call the ImageLoaderCompat function from Java: GetRequest request = ImageLoaders . newGetBuilder ( imageLoader ) . data ( https://www.example.com/image.jpg ) . size ( 1080 , 1920 ) . build (); Drawable drawable = ImageLoaderCompat . getBlocking ( imageLoader , request ); Note ImageLoaderCompat.getBlocking will block the current thread instead of suspending. Do not call this from the main thread.","title":"Java Compatibility"},{"location":"migrating/","text":"Migrating from Glide/Picasso Here are a few examples of how to migrate Glide/Picasso calls into Coil calls: Basic Usage // Glide Glide . with ( context ) . load ( url ) . into ( imageView ) // Picasso Picasso . get () . load ( url ) . into ( imageView ) // Coil imageView . load ( url ) Custom Requests imageView . scaleType = ImageView . ScaleType . FIT_CENTER // Glide Glide . with ( context ) . load ( url ) . placeholder ( placeholder ) . fitCenter () . into ( imageView ) // Picasso Picasso . get () . load ( url ) . placeholder ( placeholder ) . fit () . into ( imageView ) // Coil (autodetects the scale type) imageView . load ( url ) { placeholder ( placeholder ) } Non-View Targets // Glide (has optional callbacks for start and error) Glide . with ( context ) . load ( url ) . into ( object : CustomTarget Drawable () { override fun onResourceReady ( resource : Drawable , transition : Transition Drawable ) { // Handle the successful result. } override fun onLoadCleared ( placeholder : Drawable ) { // Remove the drawable provided in onResourceReady from any Views and ensure no references to it remain. } }) // Picasso Picasso . get () . load ( url ) . into ( object : BitmapTarget { override fun onBitmapLoaded ( bitmap : Bitmap , from : Picasso . LoadedFrom ) { // Handle the successful result. } override fun onBitmapFailed ( e : Exception , errorDrawable : Drawable ?) { // Handle the error drawable. } override fun onPrepareLoad ( placeHolderDrawable : Drawable ?) { // Handle the placeholder drawable. } }) // Coil (has optional callbacks for start and error) Coil . load ( context , url ) { target { drawable - // Handle the successful result. } } Background Thread // Glide (blocks the current thread; must not be called from the main thread) val drawable = Glide . with ( context ) . load ( url ) . submit ( width , height ) . get () // Picasso (blocks the current thread; must not be called from the main thread) val drawable = Picasso . get () . load ( url ) . resize ( width , height ) . get () // Coil (suspends the current context; thread safe) val drawable = Coil . get ( url ) { size ( width , height ) }","title":"Migrating from Glide/Picasso"},{"location":"migrating/#migrating-from-glidepicasso","text":"Here are a few examples of how to migrate Glide/Picasso calls into Coil calls:","title":"Migrating from Glide/Picasso"},{"location":"migrating/#basic-usage","text":"// Glide Glide . with ( context ) . load ( url ) . into ( imageView ) // Picasso Picasso . get () . load ( url ) . into ( imageView ) // Coil imageView . load ( url )","title":"Basic Usage"},{"location":"migrating/#custom-requests","text":"imageView . scaleType = ImageView . ScaleType . FIT_CENTER // Glide Glide . with ( context ) . load ( url ) . placeholder ( placeholder ) . fitCenter () . into ( imageView ) // Picasso Picasso . get () . load ( url ) . placeholder ( placeholder ) . fit () . into ( imageView ) // Coil (autodetects the scale type) imageView . load ( url ) { placeholder ( placeholder ) }","title":"Custom Requests"},{"location":"migrating/#non-view-targets","text":"// Glide (has optional callbacks for start and error) Glide . with ( context ) . load ( url ) . into ( object : CustomTarget Drawable () { override fun onResourceReady ( resource : Drawable , transition : Transition Drawable ) { // Handle the successful result. } override fun onLoadCleared ( placeholder : Drawable ) { // Remove the drawable provided in onResourceReady from any Views and ensure no references to it remain. } }) // Picasso Picasso . get () . load ( url ) . into ( object : BitmapTarget { override fun onBitmapLoaded ( bitmap : Bitmap , from : Picasso . LoadedFrom ) { // Handle the successful result. } override fun onBitmapFailed ( e : Exception , errorDrawable : Drawable ?) { // Handle the error drawable. } override fun onPrepareLoad ( placeHolderDrawable : Drawable ?) { // Handle the placeholder drawable. } }) // Coil (has optional callbacks for start and error) Coil . load ( context , url ) { target { drawable - // Handle the successful result. } }","title":"Non-View Targets"},{"location":"migrating/#background-thread","text":"// Glide (blocks the current thread; must not be called from the main thread) val drawable = Glide . with ( context ) . load ( url ) . submit ( width , height ) . get () // Picasso (blocks the current thread; must not be called from the main thread) val drawable = Picasso . get () . load ( url ) . resize ( width , height ) . get () // Coil (suspends the current context; thread safe) val drawable = Coil . get ( url ) { size ( width , height ) }","title":"Background Thread"},{"location":"requests/","text":"Requests Requests are value objects that provide all the necessary information for an ImageLoader to execute an image request. Requests can be created a number of ways. This simplest way is to use the trailing lambda syntax: val request = LoadRequest ( context , imageLoader . defaults ) { data ( https://www.example.com/image.jpg ) crossfade ( true ) } Requests can also be created using typical builder syntax. This works best for Java: val request = imageLoader . newLoadBuilder ( context ) . data ( https://www.example.com/image.jpg ) . crossfade ( true ) . build () Once you've created a request, pass it to an ImageLoader to execute it: imageLoader . load ( request ) Optionally, you can use the type-safe load and get extension functions to create and execute requests. See the API documentation for more information.","title":"Requests"},{"location":"requests/#requests","text":"Requests are value objects that provide all the necessary information for an ImageLoader to execute an image request. Requests can be created a number of ways. This simplest way is to use the trailing lambda syntax: val request = LoadRequest ( context , imageLoader . defaults ) { data ( https://www.example.com/image.jpg ) crossfade ( true ) } Requests can also be created using typical builder syntax. This works best for Java: val request = imageLoader . newLoadBuilder ( context ) . data ( https://www.example.com/image.jpg ) . crossfade ( true ) . build () Once you've created a request, pass it to an ImageLoader to execute it: imageLoader . load ( request ) Optionally, you can use the type-safe load and get extension functions to create and execute requests. See the API documentation for more information.","title":"Requests"},{"location":"targets/","text":"Targets Targets handle the result of an image request. They often act as \"view adapters\" by taking the placeholder/error/success Drawables and applying them to a View . Here's the easiest way to create a custom target: Coil . load ( context , https://www.example.com/image.jpg ) { target { drawable - // Handle the successful result. } } There are 3 types of targets: Target : The base target class. Prefer this if the image request isn't tied to a View . ViewTarget : A target with an associated View . Prefer this if the request sets the placeholder/error/success Drawables on a View . Using ViewTarget also binds the request to the View 's lifecycle. PoolableViewTarget : A ViewTarget that supports bitmap pooling . This has performance benefits, however it comes with several strict behavior requirements. Read the docs for more information.","title":"Targets"},{"location":"targets/#targets","text":"Targets handle the result of an image request. They often act as \"view adapters\" by taking the placeholder/error/success Drawables and applying them to a View . Here's the easiest way to create a custom target: Coil . load ( context , https://www.example.com/image.jpg ) { target { drawable - // Handle the successful result. } } There are 3 types of targets: Target : The base target class. Prefer this if the image request isn't tied to a View . ViewTarget : A target with an associated View . Prefer this if the request sets the placeholder/error/success Drawables on a View . Using ViewTarget also binds the request to the View 's lifecycle. PoolableViewTarget : A ViewTarget that supports bitmap pooling . This has performance benefits, however it comes with several strict behavior requirements. Read the docs for more information.","title":"Targets"},{"location":"transformations/","text":"Transformations Transformations allow you to modify the pixel data of an image before the Drawable is returned from the request. By default, Coil comes packaged with 4 transformations: blur , circle crop , and grayscale , and rounded corners . See the API doc for more information. Note Transformations are only applied to BitmapDrawable s.","title":"Transformations"},{"location":"transformations/#transformations","text":"Transformations allow you to modify the pixel data of an image before the Drawable is returned from the request. By default, Coil comes packaged with 4 transformations: blur , circle crop , and grayscale , and rounded corners . See the API doc for more information. Note Transformations are only applied to BitmapDrawable s.","title":"Transformations"}]}