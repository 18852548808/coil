{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"An image loading library for Android backed by Kotlin Coroutines. Coil is: Fast : Coil performs a number of optimizations including memory and disk caching, downsampling the image in memory, re-using Bitmaps, automatically pausing/cancelling requests, and more. Lightweight : Coil adds ~2000 methods to your APK (for apps that already use OkHttp and Coroutines), which is comparable to Picasso and significantly less than Glide and Fresco. Easy to use : Coil's API leverages Kotlin's language features for simplicity and minimal boilerplate. Modern : Coil is Kotlin-first and uses modern libraries including Coroutines, OkHttp, Okio, and AndroidX Lifecycles. Coil is an acronym for: Co routine I mage L oader. Made with \u2764\ufe0f at Instacart . Translations: \ud55c\uad6d\uc5b4 Download \u00b6 Coil is available on mavenCentral() . implementation ( \"io.coil-kt:coil:0.11.0\" ) Quick Start \u00b6 To load an image into an ImageView , use the load extension function: // URL imageView . load ( \"https://www.example.com/image.jpg\" ) // Resource imageView . load ( R . drawable . image ) // File imageView . load ( File ( \"/path/to/image.jpg\" )) // And more... Requests can be configured with an optional trailing lambda: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } Image Loaders \u00b6 imageView.load uses the singleton ImageLoader to execute a LoadRequest . The singleton ImageLoader can be accessed using: val imageLoader = Coil . imageLoader ( context ) Optionally, you can create your own ImageLoader instance(s) and inject them with dependency injection: val imageLoader = ImageLoader ( context ) If you do not want the singleton ImageLoader , depend on io.coil-kt:coil-base . Requests \u00b6 To load an image into a custom target, execute a LoadRequest : val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target { drawable -> // Handle the result. } . build () imageLoader . execute ( request ) To get an image imperatively, execute a GetRequest : val request = GetRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val drawable = imageLoader . execute ( request ). drawable Requirements \u00b6 AndroidX Min SDK 14+ Compile SDK: 29+ Java 8+ R8 / Proguard \u00b6 Coil is fully compatible with R8 out of the box and doesn't require adding any extra rules. If you use Proguard, you may need to add rules for Coroutines , OkHttp and Okio . License \u00b6 Copyright 2020 Coil Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#download","text":"Coil is available on mavenCentral() . implementation ( \"io.coil-kt:coil:0.11.0\" )","title":"Download"},{"location":"#quick-start","text":"To load an image into an ImageView , use the load extension function: // URL imageView . load ( \"https://www.example.com/image.jpg\" ) // Resource imageView . load ( R . drawable . image ) // File imageView . load ( File ( \"/path/to/image.jpg\" )) // And more... Requests can be configured with an optional trailing lambda: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) }","title":"Quick Start"},{"location":"#image-loaders","text":"imageView.load uses the singleton ImageLoader to execute a LoadRequest . The singleton ImageLoader can be accessed using: val imageLoader = Coil . imageLoader ( context ) Optionally, you can create your own ImageLoader instance(s) and inject them with dependency injection: val imageLoader = ImageLoader ( context ) If you do not want the singleton ImageLoader , depend on io.coil-kt:coil-base .","title":"Image Loaders"},{"location":"#requests","text":"To load an image into a custom target, execute a LoadRequest : val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target { drawable -> // Handle the result. } . build () imageLoader . execute ( request ) To get an image imperatively, execute a GetRequest : val request = GetRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val drawable = imageLoader . execute ( request ). drawable","title":"Requests"},{"location":"#requirements","text":"AndroidX Min SDK 14+ Compile SDK: 29+ Java 8+","title":"Requirements"},{"location":"#r8-proguard","text":"Coil is fully compatible with R8 out of the box and doesn't require adding any extra rules. If you use Proguard, you may need to add rules for Coroutines , OkHttp and Okio .","title":"R8 / Proguard"},{"location":"#license","text":"Copyright 2020 Coil Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"README-ko/","text":"Coil\uc740 Kotlin Coroutines\uc73c\ub85c \ub9cc\ub4e4\uc5b4\uc9c4 Android \ubc31\uc564\ub4dc \uc774\ubbf8\uc9c0 \ub85c\ub529 \ub77c\uc774\ube0c\ub7ec\ub9ac\uc785\ub2c8\ub2e4. Coil \uc740: \ube60\ub974\ub2e4 : Coil\uc740 \uba54\ubaa8\ub9ac\uc640 \ub514\uc2a4\ud06c\uc758 \uce90\uc2f1, \uba54\ubaa8\ub9ac\uc758 \uc774\ubbf8\uc9c0 \ub2e4\uc6b4 \uc0d8\ud50c\ub9c1, Bitmap \uc7ac\uc0ac\uc6a9, \uc77c\uc2dc\uc815\uc9c0/\ucde8\uc18c\uc758 \uc790\ub3d9\ud654 \ub4f1\ub4f1 \uc218 \ub9ce\uc740 \ucd5c\uc801\ud654 \uc791\uc5c5\uc744 \uc218\ud589\ud569\ub2c8\ub2e4. \uac00\ubccd\ub2e4 : Coil\uc740 \ucd5c\ub300 2000\uac1c\uc758 method\ub4e4\uc744 APK\uc5d0 \ucd94\uac00\ud569\ub2c8\ub2e4(\uc774\ubbf8 OkHttp\uc640 Coroutines\uc744 \uc0ac\uc6a9\uc911\uc778 \uc571\uc5d0 \ud55c\ud558\uc5ec), \uc774\ub294 Picasso \ube44\uc2b7\ud55c \uc218\uc900\uc774\uba70 Glide\uc640 Fresco\ubcf4\ub2e4\ub294 \uc801\uc2b5\ub2c8\ub2e4. \uc0ac\uc6a9\ud558\uae30 \uc27d\ub2e4 : Coil API\ub294 \uc2ec\ud50c\ud568\uacfc \ucd5c\uc18c\ud55c\uc758 boilerplate\ub97c \uc704\ud558\uc5ec Kotlin\uc758 \uae30\ub2a5\uc744 \ud65c\uc6a9\ud569\ub2c8\ub2e4. \ud604\ub300\uc801\uc774\ub2e4 : Coil\uc740 Kotlin \uc6b0\uc120\uc774\uba70 Coroutines, OkHttp, Okio, AndroidX Lifecycles\ub4f1\uc758 \ucd5c\uc2e0 \ub77c\uc774\ube0c\ub7ec\ub9ac\ub97c \uc0ac\uc6a9\ud569\ub2c8\ub2e4. Coil\uc740: Co routine I mage L oader\uc758 \uc57d\uc790\uc785\ub2c8\ub2e4. \u2764\ufe0f Instacart \uc5d0\uc11c \u2764\ufe0f\uc73c\ub85c \ub9cc\ub4e4\uc5c8\uc2b5\ub2c8\ub2e4. \ub2e4\uc6b4\ub85c\ub4dc \u00b6 Coil\uc740 mavenCentral() \ub85c \uc774\uc6a9 \uac00\ub2a5\ud569\ub2c8\ub2e4. implementation ( \"io.coil-kt:coil:0.11.0\" ) \ube60\ub978 \uc2dc\uc791 \u00b6 ImageView \ub85c \uc774\ubbf8\uc9c0\ub97c \ubd88\ub7ec\uc624\uae30 \uc704\ud574, load \ud655\uc7a5 \ud568\uc218\ub97c \uc0ac\uc6a9\ud569\ub2c8\ub2e4. // URL imageView . load ( \"https://www.example.com/image.jpg\" ) // Resource imageView . load ( R . drawable . image ) // File imageView . load ( File ( \"/path/to/image.jpg\" )) // And more... Requests\ub294 trailing lambda \uc2dd\uc744 \uc774\uc6a9\ud558\uc5ec \ucd94\uac00 \uc124\uc815\uc744 \ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } \uc5ec\uae30\uc11c Coil\uc758 \uc804\uccb4 \ubb38\uc11c \ub97c \ud655\uc778\ud558\uc138\uc694. \uc694\uad6c\uc0ac\ud56d \u00b6 AndroidX Min SDK 14+ Compile SDK: 29+ Java 8+ R8 / Proguard \u00b6 Coil\uc740 \ubcc4\ub3c4\uc758 \uc124\uc815 \uc5c6\uc774 R8\uacfc \uc644\ubcbd\ud558\uac8c \ud638\ud658 \uac00\ub2a5\ud558\uba70 \ucd94\uac00 \uaddc\uce59\uc774 \ud544\uc694\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. Proguard\ub97c \uc0ac\uc6a9\ud560 \uacbd\uc6b0, Coroutines , OkHttp , Okio \uc5d0 \uaddc\uce59\uc744 \ucd94\uac00\ud560 \ud544\uc694\uac00 \uc788\uc744 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \ub77c\uc774\uc120\uc2a4 \u00b6 Copyright 2020 Coil Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"README ko"},{"location":"README-ko/#_1","text":"Coil\uc740 mavenCentral() \ub85c \uc774\uc6a9 \uac00\ub2a5\ud569\ub2c8\ub2e4. implementation ( \"io.coil-kt:coil:0.11.0\" )","title":"\ub2e4\uc6b4\ub85c\ub4dc"},{"location":"README-ko/#_2","text":"ImageView \ub85c \uc774\ubbf8\uc9c0\ub97c \ubd88\ub7ec\uc624\uae30 \uc704\ud574, load \ud655\uc7a5 \ud568\uc218\ub97c \uc0ac\uc6a9\ud569\ub2c8\ub2e4. // URL imageView . load ( \"https://www.example.com/image.jpg\" ) // Resource imageView . load ( R . drawable . image ) // File imageView . load ( File ( \"/path/to/image.jpg\" )) // And more... Requests\ub294 trailing lambda \uc2dd\uc744 \uc774\uc6a9\ud558\uc5ec \ucd94\uac00 \uc124\uc815\uc744 \ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } \uc5ec\uae30\uc11c Coil\uc758 \uc804\uccb4 \ubb38\uc11c \ub97c \ud655\uc778\ud558\uc138\uc694.","title":"\ube60\ub978 \uc2dc\uc791"},{"location":"README-ko/#_3","text":"AndroidX Min SDK 14+ Compile SDK: 29+ Java 8+","title":"\uc694\uad6c\uc0ac\ud56d"},{"location":"README-ko/#r8-proguard","text":"Coil\uc740 \ubcc4\ub3c4\uc758 \uc124\uc815 \uc5c6\uc774 R8\uacfc \uc644\ubcbd\ud558\uac8c \ud638\ud658 \uac00\ub2a5\ud558\uba70 \ucd94\uac00 \uaddc\uce59\uc774 \ud544\uc694\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. Proguard\ub97c \uc0ac\uc6a9\ud560 \uacbd\uc6b0, Coroutines , OkHttp , Okio \uc5d0 \uaddc\uce59\uc744 \ucd94\uac00\ud560 \ud544\uc694\uac00 \uc788\uc744 \uc218 \uc788\uc2b5\ub2c8\ub2e4.","title":"R8 / Proguard"},{"location":"README-ko/#_4","text":"Copyright 2020 Coil Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"\ub77c\uc774\uc120\uc2a4"},{"location":"changelog/","text":"Changelog \u00b6 [0.11.0] - May 14, 2020 \u00b6 Breaking : This version removes all existing deprecated functions. This enables removing Coil's ContentProvider so it doesn't run any code at app startup. Breaking : Convert SparseIntArraySet.size to a val. ( #380 ) Breaking : Move Parameters.count() to an extension function. ( #403 ) Breaking : Make BitmapPool.maxSize an Int. ( #404 ) Important : Make ImageLoader.shutdown() optional (similar to OkHttpClient ). (#385) Fix: Fix AGP 4.1 compatibility. ( #386 ) Fix: Fix measuring GONE views. ( #397 ) Reduce the default memory cache size to 20%. ( #390 ) To restore the existing behaviour set ImageLoaderBuidler.availableMemoryPercentage(0.25) when creating your ImageLoader . Update Coroutines to 1.3.6. Update OkHttp to 3.12.11. [0.10.1] - April 26, 2020 \u00b6 Fix OOM when decoding large PNGs on API 23 and below. ( #372 ). This disables decoding EXIF orientation for PNG files. PNG EXIF orientation is very rarely used and reading PNG EXIF data (even if it's empty) requires buffering the entire file into memory, which is bad for performance. Minor Java compatibility improvements to SparseIntArraySet . Update Okio to 2.6.0. [0.10.0] - April 20, 2020 \u00b6 Highlights \u00b6 This version deprecates most of the DSL API in favour of using the builders directly. Here's what the change looks like: // 0.9.5 (old) val imageLoader = ImageLoader ( context ) { bitmapPoolPercentage ( 0.5 ) crossfade ( true ) } val disposable = imageLoader . load ( context , \"https://www.example.com/image.jpg\" ) { target ( imageView ) } val drawable = imageLoader . get ( \"https://www.example.com/image.jpg\" ) { size ( 512 , 512 ) } // 0.10.0 (new) val imageLoader = ImageLoader . Builder ( context ) . bitmapPoolPercentage ( 0.5 ) . crossfade ( true ) . build () val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () val disposable = imageLoader . execute ( request ) val request = GetRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . size ( 512 , 512 ) . build () val drawable = imageLoader . execute ( request ). drawable If you're using the io.coil-kt:coil artifact, you can call Coil.execute(request) to execute the request with the singleton ImageLoader . ImageLoader s now have a weak reference memory cache that tracks weak references to images once they're evicted from the strong reference memory cache. This means an image will always be returned from an ImageLoader 's memory cache if there's still a strong reference to it. Generally, this should make the memory cache much more predictable and increase its hit rate. This behaviour can be enabled/disabled with ImageLoaderBuilder.trackWeakReferences . Add a new artifact, io.coil-kt:coil-video , to decode specific frames from a video file. Read more here . Add a new EventListener API for tracking metrics. Add ImageLoaderFactory which can be implemented by your Application to simplify singleton initialization. Full Release Notes \u00b6 Important : Deprecate DSL syntax in favour of builder syntax. ( #267 ) Important : Deprecate Coil and ImageLoader extension functions. ( #322 ) Breaking : Return sealed RequestResult type from ImageLoader.execute(GetRequest) . ( #349 ) Breaking : Rename ExperimentalCoil to ExperimentalCoilApi . Migrate from @Experimental to @RequiresOptIn . ( #306 ) Breaking : Replace CoilLogger with Logger interface. ( #316 ) Breaking : Rename destWidth/destHeight to dstWidth/dstHeight. ( #275 ) Breaking : Re-arrange MovieDrawable 's constructor params. ( #272 ) Breaking : Request.Listener 's methods now receive the full Request object instead of just its data. Breaking : GetRequestBuilder now requires a Context in its constructor. Breaking : Several properties on Request are now nullable. Behaviour change : Include parameter values in the cache key by default. ( #319 ) Behaviour change : Slightly adjust Request.Listener.onStart() timing to be called immediately after Target.onStart() . ( #348 ) New : Add WeakMemoryCache implementation. ( #295 ) New : Add coil-video to support decoding video frames. ( #122 ) New : Introduce EventListener . ( #314 ) New : Introduce ImageLoaderFactory . ( #311 ) New : Support animated HEIF image sequences on Android 11. ( #297 ) New : Improve Java compatibility. ( #262 ) New : Support setting a default CachePolicy . ( #307 ) New : Support setting a default Bitmap.Config . ( #342 ) New : Add ImageLoader.invalidate(key) to clear a single memory cache item ( #55 ) New : Add debug logs to explain why a cached image is not reused. ( #346 ) New : Support error and fallback drawables for get requests. Fix: Fix memory cache miss when Transformation reduces input bitmap's size. ( #357 ) Fix: Ensure radius is below RenderScript max in BlurTransformation. ( #291 ) Fix: Fix decoding high colour depth images. ( #358 ) Fix: Disable ImageDecoderDecoder crash work-around on Android 11 and above. ( #298 ) Fix: Fix failing to read EXIF data on pre-API 23. ( #331 ) Fix: Fix incompatibility with Android R SDK. ( #337 ) Fix: Only enable inexact size if ImageView has a matching SizeResolver . ( #344 ) Fix: Allow cached images to be at most one pixel off requested size. ( #360 ) Fix: Skip crossfade transition if view is not visible. ( #361 ) Deprecate CoilContentProvider . ( #293 ) Annotate several ImageLoader methods with @MainThread . Avoid creating a LifecycleCoroutineDispatcher if the lifecycle is currently started. ( #356 ) Use full package name for OriginalSize.toString() . Preallocate when decoding software bitmap. ( #354 ) Update Kotlin to 1.3.72. Update Coroutines to 1.3.5. Update OkHttp to 3.12.10. Update Okio to 2.5.0. Update AndroidX dependencies: androidx.exifinterface:exifinterface -> 1.2.0 [0.9.5] - February 6, 2020 \u00b6 Fix: Ensure a view is attached before checking if it is hardware accelerated. This fixes a case where requesting a hardware bitmap could miss the memory cache. Update AndroidX dependencies: androidx.core:core-ktx -> 1.2.0 [0.9.4] - February 3, 2020 \u00b6 Fix: Respect aspect ratio when downsampling in ImageDecoderDecoder. Thanks @zhanghai. Previously bitmaps would be returned from the memory cache as long as their config was greater than or equal to the config specified in the request. For example, if you requested an ARGB_8888 bitmap, it would be possible to have a RGBA_F16 bitmap returned to you from the memory cache. Now, the cached config and the requested config must be equal. Make scale and durationMillis public in CrossfadeDrawable and CrossfadeTransition . [0.9.3] - February 1, 2020 \u00b6 Fix: Translate child drawable inside ScaleDrawable to ensure it is centered. Fix: Fix case where GIFs and SVGs would not fill bounds completely. Defer calling HttpUrl.get() to background thread. Improve BitmapFactory null bitmap error message. Add 3 devices to hardware bitmap blacklist. ( #264 ) Update AndroidX dependencies: androidx.lifecycle:lifecycle-common-java8 -> 2.2.0 [0.9.2] - January 19, 2020 \u00b6 Fix: Fix decoding GIFs on pre-API 19. Thanks @mario. Fix: Fix rasterized vector drawables not being marked as sampled. Fix: Throw exception if Movie dimensions are <= 0. Fix: Fix CrossfadeTransition not being resumed for a memory cache event. Fix: Prevent returning hardware bitmaps to all target methods if disallowed. Fix: Fix MovieDrawable not positioning itself in the center of its bounds. Remove automatic scaling from CrossfadeDrawable. Make BitmapPool.trimMemory public. Wrap AnimatedImageDrawable in a ScaleDrawable to ensure it fills its bounds. Add @JvmOverloads to RequestBuilder.setParameter. Set an SVG's view box to its size if the view box is not set. Pass state and level changes to CrossfadeDrawable children. Update OkHttp to 3.12.8. [0.9.1] - December 30, 2019 \u00b6 Fix: Fix crash when calling LoadRequestBuilder.crossfade(false) . [0.9.0] - December 30, 2019 \u00b6 Breaking : Transformation.transform now includes a Size parameter. This is to support transformations that change the size of the output Bitmap based on the size of the Target . Requests with transformations are now also exempt from image sampling . Breaking : Transformation s are now applied to any type of Drawable . Before, Transformation s would be skipped if the input Drawable was not a BitmapDrawable . Now, Drawable s are rendered to a Bitmap before applying the Transformation s. Breaking : Passing null data to ImageLoader.load is now treated as an error and calls Target.onError and Request.Listener.onError with a NullRequestDataException . This change was made to support setting a fallback drawable if data is null . Previously the request was silently ignored. Breaking : RequestDisposable.isDisposed is now a val . New : Support for custom transitions. See here for more info . Transitions are marked as experimental as the API is incubating. New : Add RequestDisposable.await to support suspending while a LoadRequest is in progress. New : Support setting a fallback drawable when request data is null. New : Add Precision . This makes the size of the output Drawable exact while enabling scaling optimizations for targets that support scaling (e.g. ImageViewTarget ). See its documentation for more information. New : Add RequestBuilder.aliasKeys to support matching multiple cache keys. Fix: Make RequestDisposable thread safe. Fix: RoundedCornersTransformation now crops to the size of the target then rounds the corners. Fix: CircleCropTransformation now crops from the center. Fix: Add several devices to the hardware bitmap blacklist . Fix: Preserve aspect ratio when converting a Drawable to a Bitmap. Fix: Fix possible memory cache miss with Scale.FIT . Fix: Ensure Parameters iteration order is deterministic. Fix: Defensive copy when creating Parameters and ComponentRegistry. Fix: Ensure RealBitmapPool's maxSize >= 0. Fix: Show the start drawable if CrossfadeDrawable is not animating or done. Fix: Adjust CrossfadeDrawable to account for children with undefined intrinsic size. Fix: Fix MovieDrawable not scaling properly. Update Kotlin to 1.3.61. Update Kotlin Coroutines to 1.3.3. Update Okio to 2.4.3. Update AndroidX dependencies: androidx.exifinterface:exifinterface -> 1.1.0 [0.8.0] - October 22, 2019 \u00b6 Breaking : SvgDrawable has been removed. Instead, SVGs are now prerendered to BitmapDrawable s by SvgDecoder . This makes SVGs significantly less expensive to render on the main thread . Also SvgDecoder now requires a Context in its constructor. Breaking : SparseIntArraySet extension functions have moved to the coil.extension package. New : Support setting per-request network headers. See here for more info . New : Add new Parameters API to support passing custom data through the image pipeline. New : Support individual corner radii in RoundedCornersTransformation. Thanks @khatv911. New : Add ImageView.clear() to support proactively freeing resources. New : Support loading resources from other packages. New : Add subtractPadding attribute to ViewSizeResolver to enable/disable subtracting a view's padding when measuring. New : Improve HttpUrlFetcher MIME type detection. New : Add Animatable2Compat support to MovieDrawable and CrossfadeDrawable. New : Add RequestBuilder<*>.repeatCount to set the repeat count for a GIF. New : Add BitmapPool creation to the public API. New : Annotate Request.Listener methods with @MainThread . Fix: Make CoilContentProvider visible for testing. Fix: Include night mode in the resource cache key. Fix: Work around ImageDecoder native crash by temporarily writing the source to disk. Fix: Correctly handle contact display photo uris. Fix: Pass tint to CrossfadeDrawable's children. Fix: Fix several instances of not closing sources. Fix: Add a blacklist of devices with broken/incomplete hardware bitmap implementations. Compile against SDK 29. Update Kotlin Coroutines to 1.3.2. Update OkHttp to 3.12.6. Update Okio to 2.4.1. Change appcompat-resources from compileOnly to implementation for coil-base . [0.7.0] - September 8, 2019 \u00b6 Breaking : ImageLoaderBuilder.okHttpClient(OkHttpClient.Builder.() -> Unit) is now ImageLoaderBuilder.okHttpClient(() -> OkHttpClient) . The initializer is also now called lazily on a background thread. If you set a custom OkHttpClient you must set OkHttpClient.cache to enable disk caching. If you don't set a custom OkHttpClient , Coil will create the default OkHttpClient which has disk caching enabled. The default Coil cache can be created using CoilUtils.createDefaultCache(context) . e.g.: val imageLoader = ImageLoader ( context ) { okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) . build () } } Breaking : Fetcher.key no longer has a default implementation. Breaking : Previously, only the first applicable Mapper would be called. Now, all applicable Mapper s will be called. No API changes. Breaking : Minor named parameter renaming: url -> uri , factory -> initializer . New : coil-svg artifact, which has an SvgDecoder that supports automatically decoding SVGs. Powered by AndroidSVG . Thanks @rharter. New : load(String) and get(String) now accept any of the supported Uri schemes. e.g. You can now do imageView.load(\"file:///path/to/file.jpg\") . New : Refactor ImageLoader to use Call.Factory instead of OkHttpClient . This allows lazy initialization of the networking resources using ImageLoaderBuilder.okHttpClient { OkHttpClient() } . Thanks @ZacSweers. New : RequestBuilder.decoder to explicitly set the decoder for a request. New : ImageLoaderBuilder.allowHardware to enable/disable hardware bitmaps by default for an ImageLoader. New : Support software rendering in ImageDecoderDecoder. Fix: Multiple bugs with loading vector drawables. Fix: Support WRAP_CONTENT View dimensions. Fix: Support parsing EXIF data longer than 8192 bytes. Fix: Don't stretch drawables with different aspect ratios when crossfading. Fix: Guard against network observer failing to register due to exception. Fix: Fix divide by zero error in MovieDrawable. Thanks @R12rus. Fix: Support nested Android asset files. Thanks @JaCzekanski. Fix: Guard against running out of file descriptors on Android O and O_MR1. Fix: Don't crash when disabling memory cache. Thanks @hansenji. Fix: Ensure Target.cancel is always called from the main thread. Update Kotlin to 1.3.50. Update Kotlin Coroutines to 1.3.0. Update OkHttp to 3.12.4. Update Okio to 2.4.0. Update AndroidX dependencies to the latest stable versions: androidx.appcompat:appcompat -> 1.1.0 androidx.core:core-ktx -> 1.1.0 androidx.lifecycle:lifecycle-common-java8 -> 2.1.0 Replace appcompat with appcompat-resources as an optional compileOnly dependency. appcompat-resources is a much smaller artifact. [0.6.1] - August 16, 2019 \u00b6 New: Add transformations(List<Transformation>) to RequestBuilder. Fix: Add the last modified date to the cache key for file uris. Fix: Ensure View dimensions are evaluated to at least 1px. Fix: Clear MovieDrawable's canvas between frames. Fix: Open assets correctly. [0.6.0] - August 12, 2019 \u00b6 Initial release.","title":"Change Log"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#0110-may-14-2020","text":"Breaking : This version removes all existing deprecated functions. This enables removing Coil's ContentProvider so it doesn't run any code at app startup. Breaking : Convert SparseIntArraySet.size to a val. ( #380 ) Breaking : Move Parameters.count() to an extension function. ( #403 ) Breaking : Make BitmapPool.maxSize an Int. ( #404 ) Important : Make ImageLoader.shutdown() optional (similar to OkHttpClient ). (#385) Fix: Fix AGP 4.1 compatibility. ( #386 ) Fix: Fix measuring GONE views. ( #397 ) Reduce the default memory cache size to 20%. ( #390 ) To restore the existing behaviour set ImageLoaderBuidler.availableMemoryPercentage(0.25) when creating your ImageLoader . Update Coroutines to 1.3.6. Update OkHttp to 3.12.11.","title":"[0.11.0] - May 14, 2020"},{"location":"changelog/#0101-april-26-2020","text":"Fix OOM when decoding large PNGs on API 23 and below. ( #372 ). This disables decoding EXIF orientation for PNG files. PNG EXIF orientation is very rarely used and reading PNG EXIF data (even if it's empty) requires buffering the entire file into memory, which is bad for performance. Minor Java compatibility improvements to SparseIntArraySet . Update Okio to 2.6.0.","title":"[0.10.1] - April 26, 2020"},{"location":"changelog/#0100-april-20-2020","text":"","title":"[0.10.0] - April 20, 2020"},{"location":"changelog/#highlights","text":"This version deprecates most of the DSL API in favour of using the builders directly. Here's what the change looks like: // 0.9.5 (old) val imageLoader = ImageLoader ( context ) { bitmapPoolPercentage ( 0.5 ) crossfade ( true ) } val disposable = imageLoader . load ( context , \"https://www.example.com/image.jpg\" ) { target ( imageView ) } val drawable = imageLoader . get ( \"https://www.example.com/image.jpg\" ) { size ( 512 , 512 ) } // 0.10.0 (new) val imageLoader = ImageLoader . Builder ( context ) . bitmapPoolPercentage ( 0.5 ) . crossfade ( true ) . build () val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () val disposable = imageLoader . execute ( request ) val request = GetRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . size ( 512 , 512 ) . build () val drawable = imageLoader . execute ( request ). drawable If you're using the io.coil-kt:coil artifact, you can call Coil.execute(request) to execute the request with the singleton ImageLoader . ImageLoader s now have a weak reference memory cache that tracks weak references to images once they're evicted from the strong reference memory cache. This means an image will always be returned from an ImageLoader 's memory cache if there's still a strong reference to it. Generally, this should make the memory cache much more predictable and increase its hit rate. This behaviour can be enabled/disabled with ImageLoaderBuilder.trackWeakReferences . Add a new artifact, io.coil-kt:coil-video , to decode specific frames from a video file. Read more here . Add a new EventListener API for tracking metrics. Add ImageLoaderFactory which can be implemented by your Application to simplify singleton initialization.","title":"Highlights"},{"location":"changelog/#full-release-notes","text":"Important : Deprecate DSL syntax in favour of builder syntax. ( #267 ) Important : Deprecate Coil and ImageLoader extension functions. ( #322 ) Breaking : Return sealed RequestResult type from ImageLoader.execute(GetRequest) . ( #349 ) Breaking : Rename ExperimentalCoil to ExperimentalCoilApi . Migrate from @Experimental to @RequiresOptIn . ( #306 ) Breaking : Replace CoilLogger with Logger interface. ( #316 ) Breaking : Rename destWidth/destHeight to dstWidth/dstHeight. ( #275 ) Breaking : Re-arrange MovieDrawable 's constructor params. ( #272 ) Breaking : Request.Listener 's methods now receive the full Request object instead of just its data. Breaking : GetRequestBuilder now requires a Context in its constructor. Breaking : Several properties on Request are now nullable. Behaviour change : Include parameter values in the cache key by default. ( #319 ) Behaviour change : Slightly adjust Request.Listener.onStart() timing to be called immediately after Target.onStart() . ( #348 ) New : Add WeakMemoryCache implementation. ( #295 ) New : Add coil-video to support decoding video frames. ( #122 ) New : Introduce EventListener . ( #314 ) New : Introduce ImageLoaderFactory . ( #311 ) New : Support animated HEIF image sequences on Android 11. ( #297 ) New : Improve Java compatibility. ( #262 ) New : Support setting a default CachePolicy . ( #307 ) New : Support setting a default Bitmap.Config . ( #342 ) New : Add ImageLoader.invalidate(key) to clear a single memory cache item ( #55 ) New : Add debug logs to explain why a cached image is not reused. ( #346 ) New : Support error and fallback drawables for get requests. Fix: Fix memory cache miss when Transformation reduces input bitmap's size. ( #357 ) Fix: Ensure radius is below RenderScript max in BlurTransformation. ( #291 ) Fix: Fix decoding high colour depth images. ( #358 ) Fix: Disable ImageDecoderDecoder crash work-around on Android 11 and above. ( #298 ) Fix: Fix failing to read EXIF data on pre-API 23. ( #331 ) Fix: Fix incompatibility with Android R SDK. ( #337 ) Fix: Only enable inexact size if ImageView has a matching SizeResolver . ( #344 ) Fix: Allow cached images to be at most one pixel off requested size. ( #360 ) Fix: Skip crossfade transition if view is not visible. ( #361 ) Deprecate CoilContentProvider . ( #293 ) Annotate several ImageLoader methods with @MainThread . Avoid creating a LifecycleCoroutineDispatcher if the lifecycle is currently started. ( #356 ) Use full package name for OriginalSize.toString() . Preallocate when decoding software bitmap. ( #354 ) Update Kotlin to 1.3.72. Update Coroutines to 1.3.5. Update OkHttp to 3.12.10. Update Okio to 2.5.0. Update AndroidX dependencies: androidx.exifinterface:exifinterface -> 1.2.0","title":"Full Release Notes"},{"location":"changelog/#095-february-6-2020","text":"Fix: Ensure a view is attached before checking if it is hardware accelerated. This fixes a case where requesting a hardware bitmap could miss the memory cache. Update AndroidX dependencies: androidx.core:core-ktx -> 1.2.0","title":"[0.9.5] - February 6, 2020"},{"location":"changelog/#094-february-3-2020","text":"Fix: Respect aspect ratio when downsampling in ImageDecoderDecoder. Thanks @zhanghai. Previously bitmaps would be returned from the memory cache as long as their config was greater than or equal to the config specified in the request. For example, if you requested an ARGB_8888 bitmap, it would be possible to have a RGBA_F16 bitmap returned to you from the memory cache. Now, the cached config and the requested config must be equal. Make scale and durationMillis public in CrossfadeDrawable and CrossfadeTransition .","title":"[0.9.4] - February 3, 2020"},{"location":"changelog/#093-february-1-2020","text":"Fix: Translate child drawable inside ScaleDrawable to ensure it is centered. Fix: Fix case where GIFs and SVGs would not fill bounds completely. Defer calling HttpUrl.get() to background thread. Improve BitmapFactory null bitmap error message. Add 3 devices to hardware bitmap blacklist. ( #264 ) Update AndroidX dependencies: androidx.lifecycle:lifecycle-common-java8 -> 2.2.0","title":"[0.9.3] - February 1, 2020"},{"location":"changelog/#092-january-19-2020","text":"Fix: Fix decoding GIFs on pre-API 19. Thanks @mario. Fix: Fix rasterized vector drawables not being marked as sampled. Fix: Throw exception if Movie dimensions are <= 0. Fix: Fix CrossfadeTransition not being resumed for a memory cache event. Fix: Prevent returning hardware bitmaps to all target methods if disallowed. Fix: Fix MovieDrawable not positioning itself in the center of its bounds. Remove automatic scaling from CrossfadeDrawable. Make BitmapPool.trimMemory public. Wrap AnimatedImageDrawable in a ScaleDrawable to ensure it fills its bounds. Add @JvmOverloads to RequestBuilder.setParameter. Set an SVG's view box to its size if the view box is not set. Pass state and level changes to CrossfadeDrawable children. Update OkHttp to 3.12.8.","title":"[0.9.2] - January 19, 2020"},{"location":"changelog/#091-december-30-2019","text":"Fix: Fix crash when calling LoadRequestBuilder.crossfade(false) .","title":"[0.9.1] - December 30, 2019"},{"location":"changelog/#090-december-30-2019","text":"Breaking : Transformation.transform now includes a Size parameter. This is to support transformations that change the size of the output Bitmap based on the size of the Target . Requests with transformations are now also exempt from image sampling . Breaking : Transformation s are now applied to any type of Drawable . Before, Transformation s would be skipped if the input Drawable was not a BitmapDrawable . Now, Drawable s are rendered to a Bitmap before applying the Transformation s. Breaking : Passing null data to ImageLoader.load is now treated as an error and calls Target.onError and Request.Listener.onError with a NullRequestDataException . This change was made to support setting a fallback drawable if data is null . Previously the request was silently ignored. Breaking : RequestDisposable.isDisposed is now a val . New : Support for custom transitions. See here for more info . Transitions are marked as experimental as the API is incubating. New : Add RequestDisposable.await to support suspending while a LoadRequest is in progress. New : Support setting a fallback drawable when request data is null. New : Add Precision . This makes the size of the output Drawable exact while enabling scaling optimizations for targets that support scaling (e.g. ImageViewTarget ). See its documentation for more information. New : Add RequestBuilder.aliasKeys to support matching multiple cache keys. Fix: Make RequestDisposable thread safe. Fix: RoundedCornersTransformation now crops to the size of the target then rounds the corners. Fix: CircleCropTransformation now crops from the center. Fix: Add several devices to the hardware bitmap blacklist . Fix: Preserve aspect ratio when converting a Drawable to a Bitmap. Fix: Fix possible memory cache miss with Scale.FIT . Fix: Ensure Parameters iteration order is deterministic. Fix: Defensive copy when creating Parameters and ComponentRegistry. Fix: Ensure RealBitmapPool's maxSize >= 0. Fix: Show the start drawable if CrossfadeDrawable is not animating or done. Fix: Adjust CrossfadeDrawable to account for children with undefined intrinsic size. Fix: Fix MovieDrawable not scaling properly. Update Kotlin to 1.3.61. Update Kotlin Coroutines to 1.3.3. Update Okio to 2.4.3. Update AndroidX dependencies: androidx.exifinterface:exifinterface -> 1.1.0","title":"[0.9.0] - December 30, 2019"},{"location":"changelog/#080-october-22-2019","text":"Breaking : SvgDrawable has been removed. Instead, SVGs are now prerendered to BitmapDrawable s by SvgDecoder . This makes SVGs significantly less expensive to render on the main thread . Also SvgDecoder now requires a Context in its constructor. Breaking : SparseIntArraySet extension functions have moved to the coil.extension package. New : Support setting per-request network headers. See here for more info . New : Add new Parameters API to support passing custom data through the image pipeline. New : Support individual corner radii in RoundedCornersTransformation. Thanks @khatv911. New : Add ImageView.clear() to support proactively freeing resources. New : Support loading resources from other packages. New : Add subtractPadding attribute to ViewSizeResolver to enable/disable subtracting a view's padding when measuring. New : Improve HttpUrlFetcher MIME type detection. New : Add Animatable2Compat support to MovieDrawable and CrossfadeDrawable. New : Add RequestBuilder<*>.repeatCount to set the repeat count for a GIF. New : Add BitmapPool creation to the public API. New : Annotate Request.Listener methods with @MainThread . Fix: Make CoilContentProvider visible for testing. Fix: Include night mode in the resource cache key. Fix: Work around ImageDecoder native crash by temporarily writing the source to disk. Fix: Correctly handle contact display photo uris. Fix: Pass tint to CrossfadeDrawable's children. Fix: Fix several instances of not closing sources. Fix: Add a blacklist of devices with broken/incomplete hardware bitmap implementations. Compile against SDK 29. Update Kotlin Coroutines to 1.3.2. Update OkHttp to 3.12.6. Update Okio to 2.4.1. Change appcompat-resources from compileOnly to implementation for coil-base .","title":"[0.8.0] - October 22, 2019"},{"location":"changelog/#070-september-8-2019","text":"Breaking : ImageLoaderBuilder.okHttpClient(OkHttpClient.Builder.() -> Unit) is now ImageLoaderBuilder.okHttpClient(() -> OkHttpClient) . The initializer is also now called lazily on a background thread. If you set a custom OkHttpClient you must set OkHttpClient.cache to enable disk caching. If you don't set a custom OkHttpClient , Coil will create the default OkHttpClient which has disk caching enabled. The default Coil cache can be created using CoilUtils.createDefaultCache(context) . e.g.: val imageLoader = ImageLoader ( context ) { okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) . build () } } Breaking : Fetcher.key no longer has a default implementation. Breaking : Previously, only the first applicable Mapper would be called. Now, all applicable Mapper s will be called. No API changes. Breaking : Minor named parameter renaming: url -> uri , factory -> initializer . New : coil-svg artifact, which has an SvgDecoder that supports automatically decoding SVGs. Powered by AndroidSVG . Thanks @rharter. New : load(String) and get(String) now accept any of the supported Uri schemes. e.g. You can now do imageView.load(\"file:///path/to/file.jpg\") . New : Refactor ImageLoader to use Call.Factory instead of OkHttpClient . This allows lazy initialization of the networking resources using ImageLoaderBuilder.okHttpClient { OkHttpClient() } . Thanks @ZacSweers. New : RequestBuilder.decoder to explicitly set the decoder for a request. New : ImageLoaderBuilder.allowHardware to enable/disable hardware bitmaps by default for an ImageLoader. New : Support software rendering in ImageDecoderDecoder. Fix: Multiple bugs with loading vector drawables. Fix: Support WRAP_CONTENT View dimensions. Fix: Support parsing EXIF data longer than 8192 bytes. Fix: Don't stretch drawables with different aspect ratios when crossfading. Fix: Guard against network observer failing to register due to exception. Fix: Fix divide by zero error in MovieDrawable. Thanks @R12rus. Fix: Support nested Android asset files. Thanks @JaCzekanski. Fix: Guard against running out of file descriptors on Android O and O_MR1. Fix: Don't crash when disabling memory cache. Thanks @hansenji. Fix: Ensure Target.cancel is always called from the main thread. Update Kotlin to 1.3.50. Update Kotlin Coroutines to 1.3.0. Update OkHttp to 3.12.4. Update Okio to 2.4.0. Update AndroidX dependencies to the latest stable versions: androidx.appcompat:appcompat -> 1.1.0 androidx.core:core-ktx -> 1.1.0 androidx.lifecycle:lifecycle-common-java8 -> 2.1.0 Replace appcompat with appcompat-resources as an optional compileOnly dependency. appcompat-resources is a much smaller artifact.","title":"[0.7.0] - September 8, 2019"},{"location":"changelog/#061-august-16-2019","text":"New: Add transformations(List<Transformation>) to RequestBuilder. Fix: Add the last modified date to the cache key for file uris. Fix: Ensure View dimensions are evaluated to at least 1px. Fix: Clear MovieDrawable's canvas between frames. Fix: Open assets correctly.","title":"[0.6.1] - August 16, 2019"},{"location":"changelog/#060-august-12-2019","text":"Initial release.","title":"[0.6.0] - August 12, 2019"},{"location":"code_of_conduct/","text":"Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at colin at colinwhite.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Code of Conduct"},{"location":"code_of_conduct/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at colin at colinwhite.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00b6 In an effort to keep the library small and stable, please keep contributions limited to bug fixes, documentation improvements, and test improvements. Issues that are tagged as help wanted are great issues to get started contributing to Coil. If you have a new feature idea, please create an enhancement request so it can be discussed or build it in an external library. If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it. If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code passes all tests by running ./test.sh . Modified from OkHttp's Contributing section.","title":"Contributing"},{"location":"contributing/#contributing","text":"In an effort to keep the library small and stable, please keep contributions limited to bug fixes, documentation improvements, and test improvements. Issues that are tagged as help wanted are great issues to get started contributing to Coil. If you have a new feature idea, please create an enhancement request so it can be discussed or build it in an external library. If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it. If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code passes all tests by running ./test.sh . Modified from OkHttp's Contributing section.","title":"Contributing"},{"location":"faq/","text":"FAQ \u00b6 Have a question that isn't part of the FAQ? Check StackOverflow with the tag #coil or search our Github issues . Can Coil be used with Java projects or mixed Kotlin/Java projects? \u00b6 Yes! Read here . How do I preload an image? \u00b6 Read here . How do I set up disk caching? \u00b6 Read here . How do I enable logging? \u00b6 Set logger(DebugLogger()) when constructing your ImageLoader . Note DebugLogger should only be used in debug builds. How do I get development snapshots? \u00b6 Add the snapshots repository to your list of repositories: Gradle ( .gradle ): allprojects { repositories { maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' } } } Gradle Kotlin DSL ( .gradle.kts ): allprojects { repositories { maven ( \"https://oss.sonatype.org/content/repositories/snapshots\" ) } } Then depend on the same artifacts with the latest snapshot version . Note Snapshots are deployed for each new commit on master that passes CI. They can potentially contain breaking changes or may be unstable. Use at your own risk.","title":"FAQ"},{"location":"faq/#faq","text":"Have a question that isn't part of the FAQ? Check StackOverflow with the tag #coil or search our Github issues .","title":"FAQ"},{"location":"faq/#can-coil-be-used-with-java-projects-or-mixed-kotlinjava-projects","text":"Yes! Read here .","title":"Can Coil be used with Java projects or mixed Kotlin/Java projects?"},{"location":"faq/#how-do-i-preload-an-image","text":"Read here .","title":"How do I preload an image?"},{"location":"faq/#how-do-i-set-up-disk-caching","text":"Read here .","title":"How do I set up disk caching?"},{"location":"faq/#how-do-i-enable-logging","text":"Set logger(DebugLogger()) when constructing your ImageLoader . Note DebugLogger should only be used in debug builds.","title":"How do I enable logging?"},{"location":"faq/#how-do-i-get-development-snapshots","text":"Add the snapshots repository to your list of repositories: Gradle ( .gradle ): allprojects { repositories { maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' } } } Gradle Kotlin DSL ( .gradle.kts ): allprojects { repositories { maven ( \"https://oss.sonatype.org/content/repositories/snapshots\" ) } } Then depend on the same artifacts with the latest snapshot version . Note Snapshots are deployed for each new commit on master that passes CI. They can potentially contain breaking changes or may be unstable. Use at your own risk.","title":"How do I get development snapshots?"},{"location":"getting_started/","text":"Getting Started \u00b6 Artifacts \u00b6 Coil has 5 artifacts published to mavenCentral() : io.coil-kt:coil : The default artifact which depends on io.coil-kt:coil-base and includes the Coil singleton and ImageView.load extension functions. io.coil-kt:coil-base : The base artifact which does not include the Coil singleton and ImageView.load extension functions. io.coil-kt:coil-gif : Includes a set of decoders to support decoding GIFs. See GIFs for more details. io.coil-kt:coil-svg : Includes a decoder to support decoding SVGs. See SVGs for more details. io.coil-kt:coil-video : Includes two fetchers to support fetching and decoding frames from any of Android's supported video formats . See videos for more details. You should depend on io.coil-kt:coil-base and not io.coil-kt:coil if either of the following is true: You are writing a library that depends on Coil. This is to avoid opting your users into the singleton. You want to use dependency injection to inject your ImageLoader instance(s). If you need transformations that aren't part of the base Coil artifact, check out the third-party coil-transformations library hosted here . Java 8 \u00b6 Coil requires Java 8 bytecode. To enable Java 8 desugaring by D8 add the following to your Gradle build script: Gradle ( .gradle ): android { compileOptions { sourceCompatibility JavaVersion . VERSION_1_8 targetCompatibility JavaVersion . VERSION_1_8 } } tasks . withType ( org . jetbrains . kotlin . gradle . tasks . KotlinCompile ). all { kotlinOptions { jvmTarget = \"1.8\" } } Gradle Kotlin DSL ( .gradle.kts ): android { compileOptions { sourceCompatibility = JavaVersion . VERSION_1_8 targetCompatibility = JavaVersion . VERSION_1_8 } } tasks . withType < KotlinCompile > { kotlinOptions { jvmTarget = \"1.8\" } } Image Loaders \u00b6 ImageLoader s are service classes that execute Request s. They handle caching, data fetching, image decoding, request management, bitmap pooling, memory management, and more. New instances can be created and configured using a builder: val imageLoader = ImageLoader . Builder ( context ) . availableMemoryPercentage ( 0.25 ) . crossfade ( true ) . build () Coil performs best when you create a single ImageLoader and share it throughout your app. This is because each ImageLoader has its own memory cache, bitmap pool, and network observer. It's recommended, though not required, to call [shutdown] when you've finished using an image loader. This preemptively frees its memory and cleans up any observers. If you only create and use one ImageLoader , you do not need to shut it down as it will be freed when your app is killed. Requests \u00b6 There are two types of Request s: LoadRequest : A request that is scoped to a Lifecycle and supports Target s, Transition s, and more. GetRequest : A request that suspends and returns a RequestResult . All requests should set data (i.e. url, uri, file, drawable resource, etc.). This is what the ImageLoader will use to decide where to fetch the image data from. Additionally, you likely want to set a target when creating a LoadRequest . It's optional, but the target is what will receive the loaded placeholder/success/error drawables. Here's an example: // LoadRequest val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () val disposable = imageLoader . execute ( request ) // GetRequest val request = GetRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val result = imageLoader . execute ( request ) Singleton \u00b6 If you are using the io.coil-kt:coil artifact, you can set a default ImageLoader instance by either: Implementing ImageLoaderFactory on your Application class (prefer this method): class MyApplication : Application (), ImageLoaderFactory { override fun newImageLoader (): ImageLoader { return ImageLoader . Builder ( context ) . crossfade ( true ) . okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) . build () } . build () } } Or calling Coil.setImageLoader : val imageLoader = ImageLoader . Builder ( context ) . crossfade ( true ) . okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) . build () } . build () Coil . setImageLoader ( imageLoader ) The default ImageLoader can be retrieved like so: val imageLoader = Coil . imageLoader ( context ) Setting a default ImageLoader is optional. If you don't set one, Coil will lazily create an ImageLoader with the default values. If you're using the io.coil-kt:coil-base artifact, you should create your own ImageLoader instance(s) and inject them throughout your app with dependency injection. Read more about dependency injection here . Note If you set a custom OkHttpClient , you must set a cache implementation or the ImageLoader will have no disk cache. A default Coil cache instance can be created using CoilUtils.createDefaultCache . ImageView Extension Functions \u00b6 The io.coil-kt:coil artifact provides a set of type-safe ImageView extension functions. Here's an example for loading a URL into an ImageView : imageView . load ( \"https://www.example.com/image.jpg\" ) The above call is equivalent to: val imageLoader = Coil . imageLoader ( context ) val request = LoadRequest . Builder ( imageView . context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () imageLoader . execute ( request ) ImageView.load calls can be configured with an optional trailing lambda parameter: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } See the docs here and here for more information. Supported Data Types \u00b6 The base data types that are supported by all ImageLoader instances are: String (mapped to a Uri) HttpUrl Uri ( android.resource , content , file , http , and https schemes only) File @DrawableRes Int Drawable Bitmap Preloading \u00b6 To preload an image into memory, execute a LoadRequest without a Target : val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) // Optional, but setting a ViewSizeResolver will conserve memory by limiting the size the image should be preloaded into memory at. . size ( ViewSizeResolver ( imageView )) . build () imageLoader . execute ( request ) To preload a network image only into the disk cache, disable the memory cache for the request: val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . memoryCachePolicy ( CachePolicy . DISABLED ) . build () imageLoader . execute ( request ) Cancelling Requests \u00b6 LoadRequest s will be automatically cancelled if the associated View is detached, the associated Lifecycle is destroyed, or another request is started on the same View . Furthermore, each LoadRequest returns a RequestDisposable , which can be used to check if a request is in flight or dispose the request (effectively cancelling it and freeing its associated resources): val disposable = imageView . load ( \"https://www.example.com/image.jpg\" ) // Cancel the request. disposable . dispose () GetRequest s will only be cancelled if the coroutine context's job is cancelled. Image Sampling \u00b6 Suppose you have an image that is 500x500 on disk, but you only need to load it into memory at 100x100 to be displayed in a view. Coil will load the image into memory, but what happens now if you need the image at 500x500? There's still more \"quality\" to read from disk, but the image is already loaded into memory at 100x100. Ideally, we would use the 100x100 image as a placeholder while we read the image from disk at 500x500. This is exactly what Coil does and Coil handles this process automatically for all BitmapDrawables . Paired with crossfade(true) , this can create a visual effect where the image detail appears to fade in, similar to a progressive JPEG . Here's what it looks like in the sample app: Images in the list have intentionally been loaded with very low detail and the crossfade is slowed down to highlight the visual effect. Bitmap Pooling \u00b6 Similar to Glide and Fresco, Coil supports bitmap pooling. Bitmap pooling is a technique to re-use Bitmap objects once they are no longer in use (i.e. when a View is detached, a Fragment's view is destroyed, etc.). This can significantly improve memory performance (especially on pre-Oreo devices), however it creates several API limitations. To make this optimization as seamless and transparent to the consumer as possible, Targets must opt-in to bitmap pooling. To opt in, implement PoolableViewTarget ; this requires the target to release all references to its current Drawable when its next lifecycle method is called. See PoolableViewTarget for more information. Note Do not use ImageView.getDrawable if the ImageView 's Drawable has been set through Coil's ImageViewTarget . Instead, either load the image using a custom Target or copy underlying Bitmap using Bitmap.copy .","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#artifacts","text":"Coil has 5 artifacts published to mavenCentral() : io.coil-kt:coil : The default artifact which depends on io.coil-kt:coil-base and includes the Coil singleton and ImageView.load extension functions. io.coil-kt:coil-base : The base artifact which does not include the Coil singleton and ImageView.load extension functions. io.coil-kt:coil-gif : Includes a set of decoders to support decoding GIFs. See GIFs for more details. io.coil-kt:coil-svg : Includes a decoder to support decoding SVGs. See SVGs for more details. io.coil-kt:coil-video : Includes two fetchers to support fetching and decoding frames from any of Android's supported video formats . See videos for more details. You should depend on io.coil-kt:coil-base and not io.coil-kt:coil if either of the following is true: You are writing a library that depends on Coil. This is to avoid opting your users into the singleton. You want to use dependency injection to inject your ImageLoader instance(s). If you need transformations that aren't part of the base Coil artifact, check out the third-party coil-transformations library hosted here .","title":"Artifacts"},{"location":"getting_started/#java-8","text":"Coil requires Java 8 bytecode. To enable Java 8 desugaring by D8 add the following to your Gradle build script: Gradle ( .gradle ): android { compileOptions { sourceCompatibility JavaVersion . VERSION_1_8 targetCompatibility JavaVersion . VERSION_1_8 } } tasks . withType ( org . jetbrains . kotlin . gradle . tasks . KotlinCompile ). all { kotlinOptions { jvmTarget = \"1.8\" } } Gradle Kotlin DSL ( .gradle.kts ): android { compileOptions { sourceCompatibility = JavaVersion . VERSION_1_8 targetCompatibility = JavaVersion . VERSION_1_8 } } tasks . withType < KotlinCompile > { kotlinOptions { jvmTarget = \"1.8\" } }","title":"Java 8"},{"location":"getting_started/#image-loaders","text":"ImageLoader s are service classes that execute Request s. They handle caching, data fetching, image decoding, request management, bitmap pooling, memory management, and more. New instances can be created and configured using a builder: val imageLoader = ImageLoader . Builder ( context ) . availableMemoryPercentage ( 0.25 ) . crossfade ( true ) . build () Coil performs best when you create a single ImageLoader and share it throughout your app. This is because each ImageLoader has its own memory cache, bitmap pool, and network observer. It's recommended, though not required, to call [shutdown] when you've finished using an image loader. This preemptively frees its memory and cleans up any observers. If you only create and use one ImageLoader , you do not need to shut it down as it will be freed when your app is killed.","title":"Image Loaders"},{"location":"getting_started/#requests","text":"There are two types of Request s: LoadRequest : A request that is scoped to a Lifecycle and supports Target s, Transition s, and more. GetRequest : A request that suspends and returns a RequestResult . All requests should set data (i.e. url, uri, file, drawable resource, etc.). This is what the ImageLoader will use to decide where to fetch the image data from. Additionally, you likely want to set a target when creating a LoadRequest . It's optional, but the target is what will receive the loaded placeholder/success/error drawables. Here's an example: // LoadRequest val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () val disposable = imageLoader . execute ( request ) // GetRequest val request = GetRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val result = imageLoader . execute ( request )","title":"Requests"},{"location":"getting_started/#singleton","text":"If you are using the io.coil-kt:coil artifact, you can set a default ImageLoader instance by either: Implementing ImageLoaderFactory on your Application class (prefer this method): class MyApplication : Application (), ImageLoaderFactory { override fun newImageLoader (): ImageLoader { return ImageLoader . Builder ( context ) . crossfade ( true ) . okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) . build () } . build () } } Or calling Coil.setImageLoader : val imageLoader = ImageLoader . Builder ( context ) . crossfade ( true ) . okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) . build () } . build () Coil . setImageLoader ( imageLoader ) The default ImageLoader can be retrieved like so: val imageLoader = Coil . imageLoader ( context ) Setting a default ImageLoader is optional. If you don't set one, Coil will lazily create an ImageLoader with the default values. If you're using the io.coil-kt:coil-base artifact, you should create your own ImageLoader instance(s) and inject them throughout your app with dependency injection. Read more about dependency injection here . Note If you set a custom OkHttpClient , you must set a cache implementation or the ImageLoader will have no disk cache. A default Coil cache instance can be created using CoilUtils.createDefaultCache .","title":"Singleton"},{"location":"getting_started/#imageview-extension-functions","text":"The io.coil-kt:coil artifact provides a set of type-safe ImageView extension functions. Here's an example for loading a URL into an ImageView : imageView . load ( \"https://www.example.com/image.jpg\" ) The above call is equivalent to: val imageLoader = Coil . imageLoader ( context ) val request = LoadRequest . Builder ( imageView . context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () imageLoader . execute ( request ) ImageView.load calls can be configured with an optional trailing lambda parameter: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } See the docs here and here for more information.","title":"ImageView Extension Functions"},{"location":"getting_started/#supported-data-types","text":"The base data types that are supported by all ImageLoader instances are: String (mapped to a Uri) HttpUrl Uri ( android.resource , content , file , http , and https schemes only) File @DrawableRes Int Drawable Bitmap","title":"Supported Data Types"},{"location":"getting_started/#preloading","text":"To preload an image into memory, execute a LoadRequest without a Target : val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) // Optional, but setting a ViewSizeResolver will conserve memory by limiting the size the image should be preloaded into memory at. . size ( ViewSizeResolver ( imageView )) . build () imageLoader . execute ( request ) To preload a network image only into the disk cache, disable the memory cache for the request: val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . memoryCachePolicy ( CachePolicy . DISABLED ) . build () imageLoader . execute ( request )","title":"Preloading"},{"location":"getting_started/#cancelling-requests","text":"LoadRequest s will be automatically cancelled if the associated View is detached, the associated Lifecycle is destroyed, or another request is started on the same View . Furthermore, each LoadRequest returns a RequestDisposable , which can be used to check if a request is in flight or dispose the request (effectively cancelling it and freeing its associated resources): val disposable = imageView . load ( \"https://www.example.com/image.jpg\" ) // Cancel the request. disposable . dispose () GetRequest s will only be cancelled if the coroutine context's job is cancelled.","title":"Cancelling Requests"},{"location":"getting_started/#image-sampling","text":"Suppose you have an image that is 500x500 on disk, but you only need to load it into memory at 100x100 to be displayed in a view. Coil will load the image into memory, but what happens now if you need the image at 500x500? There's still more \"quality\" to read from disk, but the image is already loaded into memory at 100x100. Ideally, we would use the 100x100 image as a placeholder while we read the image from disk at 500x500. This is exactly what Coil does and Coil handles this process automatically for all BitmapDrawables . Paired with crossfade(true) , this can create a visual effect where the image detail appears to fade in, similar to a progressive JPEG . Here's what it looks like in the sample app: Images in the list have intentionally been loaded with very low detail and the crossfade is slowed down to highlight the visual effect.","title":"Image Sampling"},{"location":"getting_started/#bitmap-pooling","text":"Similar to Glide and Fresco, Coil supports bitmap pooling. Bitmap pooling is a technique to re-use Bitmap objects once they are no longer in use (i.e. when a View is detached, a Fragment's view is destroyed, etc.). This can significantly improve memory performance (especially on pre-Oreo devices), however it creates several API limitations. To make this optimization as seamless and transparent to the consumer as possible, Targets must opt-in to bitmap pooling. To opt in, implement PoolableViewTarget ; this requires the target to release all references to its current Drawable when its next lifecycle method is called. See PoolableViewTarget for more information. Note Do not use ImageView.getDrawable if the ImageView 's Drawable has been set through Coil's ImageViewTarget . Instead, either load the image using a custom Target or copy underlying Bitmap using Bitmap.copy .","title":"Bitmap Pooling"},{"location":"gifs/","text":"Gifs \u00b6 Unlike Glide, GIFs are not supported by default. However, Coil has an extension library to support them. To add GIF support, import the extension library: implementation ( \"io.coil-kt:coil-gif:0.11.0\" ) And add the decoders to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . componentRegistry { if ( SDK_INT >= 28 ) { add ( ImageDecoderDecoder ()) } else { add ( GifDecoder ()) } } . build () And that's it! The ImageLoader will automatically detect any GIFs using their file headers and decode them correctly. Note Coil includes two separate decoders to support decoding GIFs. GifDecoder supports all API levels, but is slower. ImageDecoderDecoder is powered by Android's new ImageDecoder API which is only available on API 28 and above. ImageDecoderDecoder is faster than GifDecoder and supports decoding animated WebP images and animated HEIF image sequences.","title":"GIFs"},{"location":"gifs/#gifs","text":"Unlike Glide, GIFs are not supported by default. However, Coil has an extension library to support them. To add GIF support, import the extension library: implementation ( \"io.coil-kt:coil-gif:0.11.0\" ) And add the decoders to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . componentRegistry { if ( SDK_INT >= 28 ) { add ( ImageDecoderDecoder ()) } else { add ( GifDecoder ()) } } . build () And that's it! The ImageLoader will automatically detect any GIFs using their file headers and decode them correctly. Note Coil includes two separate decoders to support decoding GIFs. GifDecoder supports all API levels, but is slower. ImageDecoderDecoder is powered by Android's new ImageDecoder API which is only available on API 28 and above. ImageDecoderDecoder is faster than GifDecoder and supports decoding animated WebP images and animated HEIF image sequences.","title":"Gifs"},{"location":"image_loaders/","text":"Image Loaders \u00b6 ImageLoader s are service objects that execute Request s. They handle caching, data fetching, image decoding, request management, bitmap pooling, memory management, and more. New instances can be created and configured using a builder: val imageLoader = ImageLoader . Builder ( context ) . availableMemoryPercentage ( 0.25 ) . crossfade ( true ) . build () Internally, this constructs a RealImageLoader using ImageLoaderBuilder . Coil performs best when you create a single ImageLoader and share it throughout your app. This is because each ImageLoader has its own memory cache, bitmap pool, and network observer. Unlike OkHttpClient s, ImageLoader s must be shut down when finished with. This clears the observers held by the image loader and frees its memory: imageLoader . shutdown () Caching \u00b6 Each ImageLoader keeps a memory cache of recently decoded Bitmap s as well as a reusable pool of Bitmap s to decode into. ImageLoader s rely on an OkHttpClient to handle disk caching. By default, every ImageLoader is already set up for disk caching and will set a max cache size of between 10-250MB depending on the remaining space on the user's device. However, if you set a custom OkHttpClient , you'll need to add the disk cache yourself. To get a Cache instance that's optimized for Coil, you can use CoilUtils.createDefaultCache . Optionally, you can create your own Cache instance with a different size + location. Here's an example: val imageLoader = ImageLoader . Builder ( context ) . okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) . build () } . build () Singleton vs. Dependency Injection \u00b6 Coil performs best when you create a single ImageLoader and share it throughout your app. This is because each ImageLoader has its own memory cache and bitmap pool. If you use a dependency injector like Dagger , then you should create a single ImageLoader instance and inject it throughout your app. However, if you'd prefer a singleton the io.coil-kt:coil artifact provides a default ImageLoader instance that can be accessed with Coil.imageLoader(context) . Read here for how to initialize the singleton ImageLoader instance. Note Use the io.coil-kt:coil-base artifact if you are using dependency injection. Testing \u00b6 ImageLoader is an interface, which you can replace with a fake implementation. For instance, you could inject a fake ImageLoader implementation which always returns the same Drawable synchronously: val fakeImageLoader = object : ImageLoader { private val drawable = ColorDrawable ( Color . BLACK ) private val disposable = object : RequestDisposable { override val isDisposed = true override fun dispose () {} override suspend fun await () {} } override val defaults = DefaultRequestOptions () override fun execute ( request : LoadRequest ): RequestDisposable { // Always call onStart before onSuccess. request . target ?. onStart ( drawable ) request . target ?. onSuccess ( drawable ) return disposable } override suspend fun execute ( request : GetRequest ): RequestResult { return SuccessResult ( drawable , DataSource . MEMORY_CACHE ) } override fun invalidate ( key : String ) {} override fun clearMemory () {} override fun shutdown () {} } This is perfect for screenshot and instrumentation tests where you want consistent rendering behavior.","title":"Image Loaders"},{"location":"image_loaders/#image-loaders","text":"ImageLoader s are service objects that execute Request s. They handle caching, data fetching, image decoding, request management, bitmap pooling, memory management, and more. New instances can be created and configured using a builder: val imageLoader = ImageLoader . Builder ( context ) . availableMemoryPercentage ( 0.25 ) . crossfade ( true ) . build () Internally, this constructs a RealImageLoader using ImageLoaderBuilder . Coil performs best when you create a single ImageLoader and share it throughout your app. This is because each ImageLoader has its own memory cache, bitmap pool, and network observer. Unlike OkHttpClient s, ImageLoader s must be shut down when finished with. This clears the observers held by the image loader and frees its memory: imageLoader . shutdown ()","title":"Image Loaders"},{"location":"image_loaders/#caching","text":"Each ImageLoader keeps a memory cache of recently decoded Bitmap s as well as a reusable pool of Bitmap s to decode into. ImageLoader s rely on an OkHttpClient to handle disk caching. By default, every ImageLoader is already set up for disk caching and will set a max cache size of between 10-250MB depending on the remaining space on the user's device. However, if you set a custom OkHttpClient , you'll need to add the disk cache yourself. To get a Cache instance that's optimized for Coil, you can use CoilUtils.createDefaultCache . Optionally, you can create your own Cache instance with a different size + location. Here's an example: val imageLoader = ImageLoader . Builder ( context ) . okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) . build () } . build ()","title":"Caching"},{"location":"image_loaders/#singleton-vs-dependency-injection","text":"Coil performs best when you create a single ImageLoader and share it throughout your app. This is because each ImageLoader has its own memory cache and bitmap pool. If you use a dependency injector like Dagger , then you should create a single ImageLoader instance and inject it throughout your app. However, if you'd prefer a singleton the io.coil-kt:coil artifact provides a default ImageLoader instance that can be accessed with Coil.imageLoader(context) . Read here for how to initialize the singleton ImageLoader instance. Note Use the io.coil-kt:coil-base artifact if you are using dependency injection.","title":"Singleton vs. Dependency Injection"},{"location":"image_loaders/#testing","text":"ImageLoader is an interface, which you can replace with a fake implementation. For instance, you could inject a fake ImageLoader implementation which always returns the same Drawable synchronously: val fakeImageLoader = object : ImageLoader { private val drawable = ColorDrawable ( Color . BLACK ) private val disposable = object : RequestDisposable { override val isDisposed = true override fun dispose () {} override suspend fun await () {} } override val defaults = DefaultRequestOptions () override fun execute ( request : LoadRequest ): RequestDisposable { // Always call onStart before onSuccess. request . target ?. onStart ( drawable ) request . target ?. onSuccess ( drawable ) return disposable } override suspend fun execute ( request : GetRequest ): RequestResult { return SuccessResult ( drawable , DataSource . MEMORY_CACHE ) } override fun invalidate ( key : String ) {} override fun clearMemory () {} override fun shutdown () {} } This is perfect for screenshot and instrumentation tests where you want consistent rendering behavior.","title":"Testing"},{"location":"image_pipeline/","text":"Extending the Image Pipeline \u00b6 Android supports many image formats out of the box, however there are also plenty of formats it does not (e.g. GIF, SVG, TIFF, etc.) Fortunately, ImageLoader s support pluggable components to add new data types, new fetching behavior, new image encodings, or otherwise overwrite the base image loading behavior. Coil's image pipeline consists of three main parts: Mappers , Fetchers , and Decoders . Custom components must be added to the ImageLoader when constructing it through its ComponentRegistry : val imageLoader = ImageLoader . Builder ( context ) . componentRegistry { add ( ItemMapper ()) add ( CronetFetcher ()) add ( GifDecoder ()) } . build () Mappers \u00b6 Mappers allow you to add support for custom data types. For instance, say we get this model from our server: data class Item ( val id : Int , val imageUrl : String , val price : Int , val weight : Double ) We could write a custom mapper to map it to its URL, which will be handled later in the pipeline: class ItemMapper : Mapper < Item , String > { override fun map ( data : Item ) = data . imageUrl } After registering it when building our ImageLoader (see above), we can safely load an Item : val request = LoadRequest . Builder ( context ) . data ( item ) . target ( imageView ) . build () imageLoader . execute ( request ) If you want to know a request's size when mapping an object, you can implement MeasuredMapper instead of Mapper . Note MeasuredMapper s force the request to suspend until the size is measured. This can prevent setting placeholders and or cached drawables synchronously. Prefer extending Mapper if you do not need to know the request's size. See Mapper and Measured Mapper for more information. Fetchers \u00b6 Fetchers translate data into either a BufferedSource or a Drawable . See Fetcher for more information. Decoders \u00b6 Decoders read a BufferedSource as input and return a Drawable . Use this interface to add support for custom file formats (e.g. GIF, SVG, TIFF, etc.). See Decoder for more information. Note Decoders are responsible for closing the BufferedSource when finished. This allows custom decoders to return a Drawable while still reading the source. This can be useful to support file types such as progressive JPEG where there is incremental information to show.","title":"Extending the Image Pipeline"},{"location":"image_pipeline/#extending-the-image-pipeline","text":"Android supports many image formats out of the box, however there are also plenty of formats it does not (e.g. GIF, SVG, TIFF, etc.) Fortunately, ImageLoader s support pluggable components to add new data types, new fetching behavior, new image encodings, or otherwise overwrite the base image loading behavior. Coil's image pipeline consists of three main parts: Mappers , Fetchers , and Decoders . Custom components must be added to the ImageLoader when constructing it through its ComponentRegistry : val imageLoader = ImageLoader . Builder ( context ) . componentRegistry { add ( ItemMapper ()) add ( CronetFetcher ()) add ( GifDecoder ()) } . build ()","title":"Extending the Image Pipeline"},{"location":"image_pipeline/#mappers","text":"Mappers allow you to add support for custom data types. For instance, say we get this model from our server: data class Item ( val id : Int , val imageUrl : String , val price : Int , val weight : Double ) We could write a custom mapper to map it to its URL, which will be handled later in the pipeline: class ItemMapper : Mapper < Item , String > { override fun map ( data : Item ) = data . imageUrl } After registering it when building our ImageLoader (see above), we can safely load an Item : val request = LoadRequest . Builder ( context ) . data ( item ) . target ( imageView ) . build () imageLoader . execute ( request ) If you want to know a request's size when mapping an object, you can implement MeasuredMapper instead of Mapper . Note MeasuredMapper s force the request to suspend until the size is measured. This can prevent setting placeholders and or cached drawables synchronously. Prefer extending Mapper if you do not need to know the request's size. See Mapper and Measured Mapper for more information.","title":"Mappers"},{"location":"image_pipeline/#fetchers","text":"Fetchers translate data into either a BufferedSource or a Drawable . See Fetcher for more information.","title":"Fetchers"},{"location":"image_pipeline/#decoders","text":"Decoders read a BufferedSource as input and return a Drawable . Use this interface to add support for custom file formats (e.g. GIF, SVG, TIFF, etc.). See Decoder for more information. Note Decoders are responsible for closing the BufferedSource when finished. This allows custom decoders to return a Drawable while still reading the source. This can be useful to support file types such as progressive JPEG where there is incremental information to show.","title":"Decoders"},{"location":"java_compatibility/","text":"Java Compatibility \u00b6 Coil's API is designed to be Kotlin-first. It leverages Kotlin language features such as inlined lambdas, receiver params, default arguments, and extension functions, which are not available in Java. Importantly, suspend functions cannot be implemented in Java. This means custom Transformations , Size Resolvers , Fetchers , and Decoders must be implemented in Kotlin. Despite these limitations, most of Coil's API is Java compatible. For instance, the syntax to launch a LoadRequest is almost the same in Java and Kotlin: LoadRequest request = LoadRequest . builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . target ( imageView ) . build (); imageLoader . execute ( request ) Note ImageView.load extension functions cannot be used from Java. Use the LoadRequest.Builder API instead. suspend functions cannot be easily called from Java. Thus, to get an image synchronously you'll have to create a wrapper function to execute GetRequest s: object ImageLoaderCompat { @JvmStatic @WorkerThread fun getBlocking ( imageLoader : ImageLoader , request : GetRequest ): RequestResult = runBlocking { imageLoader . execute ( request ) } } Then call the ImageLoaderCompat function from Java: GetRequest request = GetRequest . builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . size ( 1080 , 1920 ) . build (); Drawable drawable = ImageLoaderCompat . getBlocking ( imageLoader , request ). getDrawable (); Note ImageLoaderCompat.getBlocking will block the current thread instead of suspending. Do not call this from the main thread.","title":"Java Compatibility"},{"location":"java_compatibility/#java-compatibility","text":"Coil's API is designed to be Kotlin-first. It leverages Kotlin language features such as inlined lambdas, receiver params, default arguments, and extension functions, which are not available in Java. Importantly, suspend functions cannot be implemented in Java. This means custom Transformations , Size Resolvers , Fetchers , and Decoders must be implemented in Kotlin. Despite these limitations, most of Coil's API is Java compatible. For instance, the syntax to launch a LoadRequest is almost the same in Java and Kotlin: LoadRequest request = LoadRequest . builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . target ( imageView ) . build (); imageLoader . execute ( request ) Note ImageView.load extension functions cannot be used from Java. Use the LoadRequest.Builder API instead. suspend functions cannot be easily called from Java. Thus, to get an image synchronously you'll have to create a wrapper function to execute GetRequest s: object ImageLoaderCompat { @JvmStatic @WorkerThread fun getBlocking ( imageLoader : ImageLoader , request : GetRequest ): RequestResult = runBlocking { imageLoader . execute ( request ) } } Then call the ImageLoaderCompat function from Java: GetRequest request = GetRequest . builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . size ( 1080 , 1920 ) . build (); Drawable drawable = ImageLoaderCompat . getBlocking ( imageLoader , request ). getDrawable (); Note ImageLoaderCompat.getBlocking will block the current thread instead of suspending. Do not call this from the main thread.","title":"Java Compatibility"},{"location":"migrating/","text":"Migrating from Glide/Picasso \u00b6 Here are a few examples of how to migrate Glide/Picasso calls into Coil calls: Basic Usage \u00b6 // Glide Glide . with ( context ) . load ( url ) . into ( imageView ) // Picasso Picasso . get () . load ( url ) . into ( imageView ) // Coil imageView . load ( url ) Custom Requests \u00b6 imageView . scaleType = ImageView . ScaleType . FIT_CENTER // Glide Glide . with ( context ) . load ( url ) . placeholder ( placeholder ) . fitCenter () . into ( imageView ) // Picasso Picasso . get () . load ( url ) . placeholder ( placeholder ) . fit () . into ( imageView ) // Coil (automatically detects the scale type) imageView . load ( url ) { placeholder ( placeholder ) } Non-View Targets \u00b6 // Glide (has optional callbacks for start and error) Glide . with ( context ) . load ( url ) . into ( object : CustomTarget < Drawable >() { override fun onResourceReady ( resource : Drawable , transition : Transition < Drawable >) { // Handle the successful result. } override fun onLoadCleared ( placeholder : Drawable ) { // Remove the drawable provided in onResourceReady from any Views and ensure no references to it remain. } }) // Picasso Picasso . get () . load ( url ) . into ( object : BitmapTarget { override fun onBitmapLoaded ( bitmap : Bitmap , from : Picasso . LoadedFrom ) { // Handle the successful result. } override fun onBitmapFailed ( e : Exception , errorDrawable : Drawable ?) { // Handle the error drawable. } override fun onPrepareLoad ( placeHolderDrawable : Drawable ?) { // Handle the placeholder drawable. } }) // Coil val imageLoader = Coil . imageLoader ( context ) val request = LoadRequest . Builder ( context ) . data ( url ) . target ( onStart = { placeholder -> // Handle the placeholder drawable. }, onSuccess = { result -> // Handle the successful result. }, onError = { error -> // Handle the error drawable. } ) . build () imageLoader . execute ( request ) Background Thread \u00b6 // Glide (blocks the current thread; must not be called from the main thread) val drawable = Glide . with ( context ) . load ( url ) . submit ( width , height ) . get () // Picasso (blocks the current thread; must not be called from the main thread) val drawable = Picasso . get () . load ( url ) . resize ( width , height ) . get () // Coil (suspends the current coroutine; non-blocking and thread safe) val imageLoader = Coil . imageLoader ( context ) val request = GetRequest . Builder ( context ) . data ( url ) . size ( width , height ) . build () val drawable = imageLoader . execute ( request ). drawable","title":"Migrating from Glide/Picasso"},{"location":"migrating/#migrating-from-glidepicasso","text":"Here are a few examples of how to migrate Glide/Picasso calls into Coil calls:","title":"Migrating from Glide/Picasso"},{"location":"migrating/#basic-usage","text":"// Glide Glide . with ( context ) . load ( url ) . into ( imageView ) // Picasso Picasso . get () . load ( url ) . into ( imageView ) // Coil imageView . load ( url )","title":"Basic Usage"},{"location":"migrating/#custom-requests","text":"imageView . scaleType = ImageView . ScaleType . FIT_CENTER // Glide Glide . with ( context ) . load ( url ) . placeholder ( placeholder ) . fitCenter () . into ( imageView ) // Picasso Picasso . get () . load ( url ) . placeholder ( placeholder ) . fit () . into ( imageView ) // Coil (automatically detects the scale type) imageView . load ( url ) { placeholder ( placeholder ) }","title":"Custom Requests"},{"location":"migrating/#non-view-targets","text":"// Glide (has optional callbacks for start and error) Glide . with ( context ) . load ( url ) . into ( object : CustomTarget < Drawable >() { override fun onResourceReady ( resource : Drawable , transition : Transition < Drawable >) { // Handle the successful result. } override fun onLoadCleared ( placeholder : Drawable ) { // Remove the drawable provided in onResourceReady from any Views and ensure no references to it remain. } }) // Picasso Picasso . get () . load ( url ) . into ( object : BitmapTarget { override fun onBitmapLoaded ( bitmap : Bitmap , from : Picasso . LoadedFrom ) { // Handle the successful result. } override fun onBitmapFailed ( e : Exception , errorDrawable : Drawable ?) { // Handle the error drawable. } override fun onPrepareLoad ( placeHolderDrawable : Drawable ?) { // Handle the placeholder drawable. } }) // Coil val imageLoader = Coil . imageLoader ( context ) val request = LoadRequest . Builder ( context ) . data ( url ) . target ( onStart = { placeholder -> // Handle the placeholder drawable. }, onSuccess = { result -> // Handle the successful result. }, onError = { error -> // Handle the error drawable. } ) . build () imageLoader . execute ( request )","title":"Non-View Targets"},{"location":"migrating/#background-thread","text":"// Glide (blocks the current thread; must not be called from the main thread) val drawable = Glide . with ( context ) . load ( url ) . submit ( width , height ) . get () // Picasso (blocks the current thread; must not be called from the main thread) val drawable = Picasso . get () . load ( url ) . resize ( width , height ) . get () // Coil (suspends the current coroutine; non-blocking and thread safe) val imageLoader = Coil . imageLoader ( context ) val request = GetRequest . Builder ( context ) . data ( url ) . size ( width , height ) . build () val drawable = imageLoader . execute ( request ). drawable","title":"Background Thread"},{"location":"recipes/","text":"Recipes \u00b6 This page provides guidance on how to handle some common use cases with Coil. You might have to modify this code to fix your exact requirements, but it should hopefully give you a push in the right direction! See a common use case that isn't covered? Feel free to submit a PR with a new section. Palette \u00b6 Palette allows you to exact prominent colors from an image. To create a Palette , you'll need access to an image's Bitmap . This can be done a number of ways: LoadRequest \u00b6 You can get access to an image's bitmap by setting a Target on a LoadRequest : val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . allowHardware ( false ) // Disable hardware bitmaps. . target { drawable -> val bitmap = ( result . drawable as BitmapDrawable ). bitmap // Generate the Palette on a background thread. val task = Palette . Builder ( bitmap ). generateAsync { palette -> // Consume the palette. } } . build () val disposable = imageLoader . execute ( request ) GetRequest \u00b6 You can also use a GetRequest , which returns the drawable imperatively: val request = GetRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . allowHardware ( false ) // Disable hardware bitmaps. . build () val drawable = ( imageLoader . execute ( request ) as SuccessResult ). drawable val palette = coroutineScope { launch ( Dispatchers . IO ) { Palette . Builder (( result . drawable as BitmapDrawable ). bitmap ). generate () } } Transition \u00b6 There may be cases where you want to load an image into a PoolableViewTarget (e.g. ImageViewTarget ) while extracting the image's colors in parallel. For these cases, you can use a custom Transition to get access to the underlying bitmap: class PaletteTransition ( private val delegate : Transition ?, private val onGenerated : ( Palette ) -> Unit ) : Transition { override suspend fun transition ( target : TransitionTarget <*>, result : RequestResult ) { // Execute the delegate transition. val delegateJob = delegate ?. let { delegate -> coroutineScope { launch ( Dispatchers . Main . immediate ) { delegate . transition ( target , result ) } } } // Compute the palette on a background thread. if ( result is SuccessResult ) { val bitmap = ( result . drawable as BitmapDrawable ). bitmap withContext ( Dispatchers . IO ) { onGenerated ( Palette . Builder ( bitmap ). generate ()) } } delegateJob ?. join () } } // LoadRequest val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . allowHardware ( false ) // Disable hardware bitmaps. . transition ( PaletteTransition ( CrossfadeTransition ()) { palette -> // Consume the palette. }) . target ( imageView ) . build () imageLoader . execute ( request ) // ImageView.load imageView . load ( \"https://www.example.com/image.jpg\" ) { allowHardware ( false ) transition ( PaletteTransition ( CrossfadeTransition ())) { palette -> // Consume the palette. } } Note You should not pass the drawable outside of Transition.transition . This can cause the drawable's underlying bitmap to be pooled while it is still in use, which can result in rendering issues and crashes. Using a custom OkHttpClient \u00b6 Coil uses OkHttp for all its networking operations. You can specify a custom OkHttpClient when creating your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) // Create the OkHttpClient inside a lambda so it will be initialized lazily on a background thread. . okHttpClient { OkHttpClient . Builder () // You need to set the cache for disk caching to work. . cache ( CoilUtils . createDefaultCache ( context )) . build () } . build () Note If you already have a built OkHttpClient , use newBuilder() to build a new client that shares resources with the original. Also, it's recommended to use a separate Cache instance for your Coil OkHttpClient . Image files can quickly evict more important cached network responses if they share the same cache. Headers \u00b6 Headers can be added to your image requests in one of two ways. You can set headers for a single request: val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . setHeader ( \"Cache-Control\" , \"max-age=31536000,public\" ) . target ( imageView ) . build () imageLoader . execute ( request ) Or you can create an Interceptor that sets headers for every request executed by your ImageLoader : class ResponseHeaderInterceptor ( private val name : String , private val value : String ) : Interceptor { override fun intercept ( chain : Interceptor . Chain ): Response { val response = chain . proceed ( chain . request ()) return response . newBuilder (). header ( name , value ). build () } } val imageLoader = ImageLoader . Builder ( context ) . okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) // This header will be added to every image request. . addNetworkInterceptor ( ResponseHeaderInterceptor ( \"Cache-Control\" , \"max-age=31536000,public\" )) . build () } . build () Shared Element Transitions \u00b6 Shared element transitions allow you to animate between Activites and Fragments . Here are some recommendations on how use them with Coil: Shared element transitions are incompatible with hardware bitmaps. You should set allowHardware(false) to disable hardware bitmaps for both the ImageView you are animating from and the view you are animating to. If you don't, the transition will throw an java.lang.IllegalArgumentException: Software rendering doesn't support hardware bitmaps exception. Prefer using target(imageView) or ImageView.load for any requests targeting an ImageView in the transition. Use ChangeImageTransform and ChangeBounds together for optimal results.","title":"Recipes"},{"location":"recipes/#recipes","text":"This page provides guidance on how to handle some common use cases with Coil. You might have to modify this code to fix your exact requirements, but it should hopefully give you a push in the right direction! See a common use case that isn't covered? Feel free to submit a PR with a new section.","title":"Recipes"},{"location":"recipes/#palette","text":"Palette allows you to exact prominent colors from an image. To create a Palette , you'll need access to an image's Bitmap . This can be done a number of ways:","title":"Palette"},{"location":"recipes/#loadrequest","text":"You can get access to an image's bitmap by setting a Target on a LoadRequest : val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . allowHardware ( false ) // Disable hardware bitmaps. . target { drawable -> val bitmap = ( result . drawable as BitmapDrawable ). bitmap // Generate the Palette on a background thread. val task = Palette . Builder ( bitmap ). generateAsync { palette -> // Consume the palette. } } . build () val disposable = imageLoader . execute ( request )","title":"LoadRequest"},{"location":"recipes/#getrequest","text":"You can also use a GetRequest , which returns the drawable imperatively: val request = GetRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . allowHardware ( false ) // Disable hardware bitmaps. . build () val drawable = ( imageLoader . execute ( request ) as SuccessResult ). drawable val palette = coroutineScope { launch ( Dispatchers . IO ) { Palette . Builder (( result . drawable as BitmapDrawable ). bitmap ). generate () } }","title":"GetRequest"},{"location":"recipes/#transition","text":"There may be cases where you want to load an image into a PoolableViewTarget (e.g. ImageViewTarget ) while extracting the image's colors in parallel. For these cases, you can use a custom Transition to get access to the underlying bitmap: class PaletteTransition ( private val delegate : Transition ?, private val onGenerated : ( Palette ) -> Unit ) : Transition { override suspend fun transition ( target : TransitionTarget <*>, result : RequestResult ) { // Execute the delegate transition. val delegateJob = delegate ?. let { delegate -> coroutineScope { launch ( Dispatchers . Main . immediate ) { delegate . transition ( target , result ) } } } // Compute the palette on a background thread. if ( result is SuccessResult ) { val bitmap = ( result . drawable as BitmapDrawable ). bitmap withContext ( Dispatchers . IO ) { onGenerated ( Palette . Builder ( bitmap ). generate ()) } } delegateJob ?. join () } } // LoadRequest val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . allowHardware ( false ) // Disable hardware bitmaps. . transition ( PaletteTransition ( CrossfadeTransition ()) { palette -> // Consume the palette. }) . target ( imageView ) . build () imageLoader . execute ( request ) // ImageView.load imageView . load ( \"https://www.example.com/image.jpg\" ) { allowHardware ( false ) transition ( PaletteTransition ( CrossfadeTransition ())) { palette -> // Consume the palette. } } Note You should not pass the drawable outside of Transition.transition . This can cause the drawable's underlying bitmap to be pooled while it is still in use, which can result in rendering issues and crashes.","title":"Transition"},{"location":"recipes/#using-a-custom-okhttpclient","text":"Coil uses OkHttp for all its networking operations. You can specify a custom OkHttpClient when creating your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) // Create the OkHttpClient inside a lambda so it will be initialized lazily on a background thread. . okHttpClient { OkHttpClient . Builder () // You need to set the cache for disk caching to work. . cache ( CoilUtils . createDefaultCache ( context )) . build () } . build () Note If you already have a built OkHttpClient , use newBuilder() to build a new client that shares resources with the original. Also, it's recommended to use a separate Cache instance for your Coil OkHttpClient . Image files can quickly evict more important cached network responses if they share the same cache.","title":"Using a custom OkHttpClient"},{"location":"recipes/#headers","text":"Headers can be added to your image requests in one of two ways. You can set headers for a single request: val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . setHeader ( \"Cache-Control\" , \"max-age=31536000,public\" ) . target ( imageView ) . build () imageLoader . execute ( request ) Or you can create an Interceptor that sets headers for every request executed by your ImageLoader : class ResponseHeaderInterceptor ( private val name : String , private val value : String ) : Interceptor { override fun intercept ( chain : Interceptor . Chain ): Response { val response = chain . proceed ( chain . request ()) return response . newBuilder (). header ( name , value ). build () } } val imageLoader = ImageLoader . Builder ( context ) . okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) // This header will be added to every image request. . addNetworkInterceptor ( ResponseHeaderInterceptor ( \"Cache-Control\" , \"max-age=31536000,public\" )) . build () } . build ()","title":"Headers"},{"location":"recipes/#shared-element-transitions","text":"Shared element transitions allow you to animate between Activites and Fragments . Here are some recommendations on how use them with Coil: Shared element transitions are incompatible with hardware bitmaps. You should set allowHardware(false) to disable hardware bitmaps for both the ImageView you are animating from and the view you are animating to. If you don't, the transition will throw an java.lang.IllegalArgumentException: Software rendering doesn't support hardware bitmaps exception. Prefer using target(imageView) or ImageView.load for any requests targeting an ImageView in the transition. Use ChangeImageTransform and ChangeBounds together for optimal results.","title":"Shared Element Transitions"},{"location":"requests/","text":"Requests \u00b6 Requests are value objects that provide all the necessary information for an ImageLoader to execute an image request. There are two types of Request s: LoadRequest : A request that is scoped to a Lifecycle and supports Target s, Transition s, and more. GetRequest : A request that suspends and returns a RequestResult . Requests can be created using a builder: val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . target ( imageView ) . build () Once you've created a request pass it to an ImageLoader to execute it: imageLoader . execute ( request ) See the API documentation for more information.","title":"Requests"},{"location":"requests/#requests","text":"Requests are value objects that provide all the necessary information for an ImageLoader to execute an image request. There are two types of Request s: LoadRequest : A request that is scoped to a Lifecycle and supports Target s, Transition s, and more. GetRequest : A request that suspends and returns a RequestResult . Requests can be created using a builder: val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . target ( imageView ) . build () Once you've created a request pass it to an ImageLoader to execute it: imageLoader . execute ( request ) See the API documentation for more information.","title":"Requests"},{"location":"svgs/","text":"SVGs \u00b6 To add SVG support, import the extension library: implementation ( \"io.coil-kt:coil-svg:0.11.0\" ) And add the decoder to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . componentRegistry { add ( SvgDecoder ()) } . build () And that's it! The ImageLoader will automatically detect any SVGs and decode them correctly.","title":"SVGs"},{"location":"svgs/#svgs","text":"To add SVG support, import the extension library: implementation ( \"io.coil-kt:coil-svg:0.11.0\" ) And add the decoder to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . componentRegistry { add ( SvgDecoder ()) } . build () And that's it! The ImageLoader will automatically detect any SVGs and decode them correctly.","title":"SVGs"},{"location":"targets/","text":"Targets \u00b6 Targets receive the result of a LoadRequest . They often act as \"view adapters\" by taking the placeholder/error/success drawables and applying them to a View (e.g. ImageViewTarget ). Here's the easiest way to create a custom target: val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( onStart = { placeholder -> // Handle the placeholder drawable. }, onSuccess = { result -> // Handle the successful result. }, onError = { error -> // Handle the error drawable. } ) . build () imageLoader . execute ( request ) There are 3 types of targets: Target : The base target class. Prefer this if the image request isn't tied to a View . ViewTarget : A target with an associated View . Prefer this if the request sets the placeholder/error/success Drawables on a View . Using ViewTarget also binds the request to the View 's lifecycle. PoolableViewTarget : A ViewTarget that supports bitmap pooling . This has performance benefits, however it comes with several strict behavior requirements. Read the docs for more information.","title":"Targets"},{"location":"targets/#targets","text":"Targets receive the result of a LoadRequest . They often act as \"view adapters\" by taking the placeholder/error/success drawables and applying them to a View (e.g. ImageViewTarget ). Here's the easiest way to create a custom target: val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( onStart = { placeholder -> // Handle the placeholder drawable. }, onSuccess = { result -> // Handle the successful result. }, onError = { error -> // Handle the error drawable. } ) . build () imageLoader . execute ( request ) There are 3 types of targets: Target : The base target class. Prefer this if the image request isn't tied to a View . ViewTarget : A target with an associated View . Prefer this if the request sets the placeholder/error/success Drawables on a View . Using ViewTarget also binds the request to the View 's lifecycle. PoolableViewTarget : A ViewTarget that supports bitmap pooling . This has performance benefits, however it comes with several strict behavior requirements. Read the docs for more information.","title":"Targets"},{"location":"transformations/","text":"Transformations \u00b6 Transformations allow you to modify the pixel data of an image before the Drawable is returned from the request. By default, Coil comes packaged with 4 transformations: blur , circle crop , and grayscale , and rounded corners . See the API doc for more information. Note If the Drawable returned by the image pipeline is not a BitmapDrawable , it will be converted to one. This will cause animated drawables to only draw the first frame of their animation.","title":"Transformations"},{"location":"transformations/#transformations","text":"Transformations allow you to modify the pixel data of an image before the Drawable is returned from the request. By default, Coil comes packaged with 4 transformations: blur , circle crop , and grayscale , and rounded corners . See the API doc for more information. Note If the Drawable returned by the image pipeline is not a BitmapDrawable , it will be converted to one. This will cause animated drawables to only draw the first frame of their animation.","title":"Transformations"},{"location":"transitions/","text":"Transitions \u00b6 Transitions allow you to animate setting the result of an image request on a Target . Both ImageLoader and LoadRequest builders accept a Transition . Transitions allow you to control how the sucess/error drawable is set on the Target . This allows you to animate the target's view or wrap the input drawable. By default, Coil comes packaged with 2 transitions: CrossfadeTransition which crossfades from the current drawable to the sucess/error drawable. Transition.NONE which sets the drawable on the Target immediately without animating. Take a look at the CrossfadeTransition source code for an example of how to write a custom Transition . See the API doc for more information.","title":"Transitions"},{"location":"transitions/#transitions","text":"Transitions allow you to animate setting the result of an image request on a Target . Both ImageLoader and LoadRequest builders accept a Transition . Transitions allow you to control how the sucess/error drawable is set on the Target . This allows you to animate the target's view or wrap the input drawable. By default, Coil comes packaged with 2 transitions: CrossfadeTransition which crossfades from the current drawable to the sucess/error drawable. Transition.NONE which sets the drawable on the Target immediately without animating. Take a look at the CrossfadeTransition source code for an example of how to write a custom Transition . See the API doc for more information.","title":"Transitions"},{"location":"videos/","text":"Video Frames \u00b6 To add video frame support, import the extension library: implementation ( \"io.coil-kt:coil-video:0.11.0\" ) And add the two fetchers to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . componentRegistry { add ( VideoFrameFileFetcher ()) add ( VideoFrameUriFetcher ()) } . build () Note Video frame decoding is only supported for File s and Uri s ( content and file schemes only). To specify the time code of the frame to extract from a video, use videoFrameMillis or videoFrameMicros : imageView . load ( File ( \"/path/to/video.mp4\" )) { videoFrameMillis ( 1000 ) } If a frame time isn't specified, the first frame of the video is decoded. And that's it! The ImageLoader will automatically detect any videos and extract their frames.","title":"Video Frames"},{"location":"videos/#video-frames","text":"To add video frame support, import the extension library: implementation ( \"io.coil-kt:coil-video:0.11.0\" ) And add the two fetchers to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . componentRegistry { add ( VideoFrameFileFetcher ()) add ( VideoFrameUriFetcher ()) } . build () Note Video frame decoding is only supported for File s and Uri s ( content and file schemes only). To specify the time code of the frame to extract from a video, use videoFrameMillis or videoFrameMicros : imageView . load ( File ( \"/path/to/video.mp4\" )) { videoFrameMillis ( 1000 ) } If a frame time isn't specified, the first frame of the video is decoded. And that's it! The ImageLoader will automatically detect any videos and extract their frames.","title":"Video Frames"}]}